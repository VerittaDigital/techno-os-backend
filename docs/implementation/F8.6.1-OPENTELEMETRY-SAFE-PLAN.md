# F8.6.1 â€” OpenTelemetry Safe Implementation Plan

## ðŸš¨ CONTEXTO: LiÃ§Ãµes do Incidente CatastrÃ³fico (2025-12-30)

**O que deu errado**:
- Script automatizado modificou cÃ³digo sem testes
- Injetou `_end_span()` sem definir a funÃ§Ã£o
- Zero validaÃ§Ã£o antes de commit
- 174 arquivos contaminados (formatting noise)
- NameError em runtime â†’ backend quebrado

**PrincÃ­pios para evitar repetiÃ§Ã£o**:
1. âœ… **Manual-only instrumentation** (ZERO automation)
2. âœ… **Test-first approach** (testes antes de instrumentar)
3. âœ… **Incremental rollout** (1 mÃ³dulo por vez)
4. âœ… **Code review humano** (linha-a-linha)
5. âœ… **Fail-closed governance** (backup before changes)

---

## ðŸ“‹ ESTRATÃ‰GIA: Incremental Instrumentation (7 Fases)

### Meta Global
Adicionar distributed tracing com OpenTelemetry **sem quebrar funcionalidade existente**.

### Completion Target
+1% (87.5% â†’ 88.5%) â€” F8.6.1 implementado e validado

---

## ðŸ” REGRAS ABSOLUTAS (NÃƒO NEGOCIÃVEIS)

### 1. Fail-closed obrigatÃ³rio
- `TRACING_ENABLED=0` por padrÃ£o (env var)
- Se tracing falhar, sistema continua funcional
- Nenhuma dependÃªncia lÃ³gica em spans

### 2. Manual-only
- **PROIBIDO** qualquer script automatizado de modificaÃ§Ã£o de cÃ³digo
- InstrumentaÃ§Ã£o linha-a-linha, com code review humano

### 3. Incremental estrito
- 1 mÃ³dulo por fase
- Nenhuma fase avanÃ§a sem `pytest 100% PASS`
- Rollback testado ao menos 1x por fase

### 4. Wrapper-only
- Nenhum span direto em funÃ§Ãµes existentes
- Spans somente via wrapper `observed_span()` (nÃ£o `create_span` direto)

### 5. Backup antes de cada fase
- `git tag PRE-PHASE-N` obrigatÃ³rio
- Rollback deve ser executado e validado

### 6. SemÃ¢ntica imutÃ¡vel
- Outputs funcionais idÃªnticos com tracing ON ou OFF
- ComparaÃ§Ã£o explÃ­cita de outputs em testes

### 7. Human code review linha-a-linha
- Zero confianÃ§a em automaÃ§Ã£o
- RevisÃ£o manual obrigatÃ³ria

---

## âš ï¸ PROIBIÃ‡Ã•ES EXPLÃCITAS

âŒ Scripts de rewrite  
âŒ InstrumentaÃ§Ã£o em massa  
âŒ AlteraÃ§Ã£o de fluxo decisÃ³rio  
âŒ Span criando dependÃªncia lÃ³gica  
âŒ "SÃ³ um ajuste rÃ¡pido"  

---

## ðŸ” FASE -1 â€” GOVERNANÃ‡A (OBRIGATÃ“RIA, 30min)

### Objetivo
Validar que sistema estÃ¡ saudÃ¡vel ANTES de iniciar instrumentaÃ§Ã£o.

### Checklist PrÃ©-Requisito

#### 1. Git clean
```bash
cd /mnt/d/Projects/techno-os-backend
git status
# Expected: "nothing to commit, working tree clean"
```

#### 2. Backend saudÃ¡vel
```bash
# Se backend nÃ£o estiver rodando, iniciar
docker-compose up -d

# Verificar health
curl -f http://localhost:8000/health
# Expected: {"status": "ok"}
```

#### 3. Smoke tests baseline
```bash
# Rodar suite completa
pytest -q

# Registrar baseline
pytest --collect-only -q | wc -l > /tmp/baseline_test_count.txt
pytest -q > /tmp/baseline_test_results.txt

# Expected: 341 tests, â‰¥99% passing
```

#### 4. Env vars baseline
```bash
# Verificar que tracing estÃ¡ desabilitado
echo "TRACING_ENABLED=${TRACING_ENABLED:-0}"
echo "OBSERVED_PIPELINE_ENABLED=${OBSERVED_PIPELINE_ENABLED:-0}"

# Expected: ambos = 0
```

#### 5. Rollback test (simulado)
```bash
# Criar arquivo temporÃ¡rio e rollback
echo "test" > /tmp/test_rollback.txt
git add /tmp/test_rollback.txt
git status  # Should show staged
git reset HEAD /tmp/test_rollback.txt
rm /tmp/test_rollback.txt

# Expected: rollback funciona
```

#### 6. Backup workspace
```bash
# Backup completo antes de qualquer mudanÃ§a
BACKUP_DIR="/mnt/d/Projects/backups-techno-os/F8.6.1-PRE-TRACING-$(date +%Y%m%d-%H%M%S)"
mkdir -p "$BACKUP_DIR"

# Backup arquivos crÃ­ticos
cp -r app "$BACKUP_DIR/"
cp -r tests "$BACKUP_DIR/"
cp requirements.txt "$BACKUP_DIR/"
cp docker-compose.yml "$BACKUP_DIR/"

echo "Backup criado em: $BACKUP_DIR"
ls -lh "$BACKUP_DIR/"
```

### Success Criteria (FASE -1)
- âœ… Git working tree clean
- âœ… Backend `/health` retorna 200 OK
- âœ… Baseline: 341 tests, â‰¥340 passing
- âœ… `TRACING_ENABLED=0` e `OBSERVED_PIPELINE_ENABLED=0`
- âœ… Rollback testado e funcional
- âœ… Backup completo criado

### âš ï¸ CRITÃ‰RIO DE BLOQUEIO
Se **qualquer item falhar** â†’ **ABORTAR implementaÃ§Ã£o** atÃ© resolver.

---

## ðŸŽ¯ FASE 0 â€” PREPARAÃ‡ÃƒO (PrÃ©-requisito, 2-3h)

### Objetivo
Configurar infraestrutura OpenTelemetry **sem tocar cÃ³digo de produÃ§Ã£o**.

### Entregas

#### 1. Instalar dependÃªncias
```bash
# requirements.txt
pip install opentelemetry-api==1.23.0
pip install opentelemetry-sdk==1.23.0
pip install opentelemetry-exporter-jaeger==1.23.0
pip install opentelemetry-instrumentation==0.44b0
```

#### 2. Deploy Jaeger (tracing backend)
```yaml
# docker-compose.tracing.yml
version: '3.8'
services:
  jaeger:
    image: jaegertracing/all-in-one:1.53
    container_name: technoos_jaeger
    ports:
      - "5775:5775/udp"   # Accept zipkin.thrift (compact)
      - "6831:6831/udp"   # Accept jaeger.thrift (compact)
      - "6832:6832/udp"   # Accept jaeger.thrift (binary)
      - "5778:5778"       # Serve configs
      - "16686:16686"     # Serve frontend (UI)
      - "14268:14268"     # Accept jaeger.thrift (HTTP)
    environment:
      - COLLECTOR_ZIPKIN_HOST_PORT=:9411
    networks:
      - techno_observability

networks:
  techno_observability:
    external: true
```

```bash
# Deploy Jaeger
docker-compose -f docker-compose.tracing.yml up -d

# Validar
curl -s http://localhost:16686/api/services | jq
# Expected: {"data": [], "total": 0, "limit": 0, "offset": 0, "errors": null}
```

#### 3. Criar mÃ³dulo tracing (SEM instrumentar ainda)
```python
# app/tracing.py
"""
OpenTelemetry tracing initialization (F8.6.1).

GOVERNANCE:
- Manual instrumentation only (no auto-instrumentation)
- Fail-closed: If tracing fails, app continues without tracing
- Privacy: No PII in span attributes
- TRACING_ENABLED=0 por padrÃ£o (env var)
"""

import os
from typing import Optional
from contextlib import nullcontext
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.jaeger.thrift import JaegerExporter
from opentelemetry.sdk.resources import Resource

_tracer: Optional[trace.Tracer] = None
_initialized = False


def is_tracing_enabled() -> bool:
    """Check if tracing is enabled via env var (fail-closed)."""
    return os.getenv("TRACING_ENABLED", "0") == "1"


def init_tracing(service_name: str = "techno-os-backend") -> Optional[trace.Tracer]:
    """
    Initialize OpenTelemetry tracing (fail-closed).
    
    Returns None if:
    - TRACING_ENABLED=0 (default)
    - Initialization fails
    
    App continues normally in both cases.
    """
    global _tracer, _initialized
    
    if _initialized:
        return _tracer
    
    # Check env var FIRST (fail-closed)
    if not is_tracing_enabled():
        print("â„¹ï¸ Tracing disabled (TRACING_ENABLED=0)")
        _tracer = None
        _initialized = True
        return None
    
    try:
        # Create resource with service name
        resource = Resource.create({"service.name": service_name})
        
        # Create tracer provider
        provider = TracerProvider(resource=resource)
        
        # Create Jaeger exporter (agent on localhost:6831)
        jaeger_exporter = JaegerExporter(
            agent_host_name="localhost",
            agent_port=6831,
        )
        
        # Add span processor (batch mode for performance)
        provider.add_span_processor(BatchSpanProcessor(jaeger_exporter))
        
        # Set as global tracer provider
        trace.set_tracer_provider(provider)
        
        # Get tracer instance
        _tracer = trace.get_tracer(__name__)
        _initialized = True
        
        print("âœ… Tracing initialized (Jaeger at localhost:6831)")
        return _tracer
    
    except Exception as e:
        # Fail-closed: If tracing init fails, continue without tracing
        print(f"âš ï¸ Tracing initialization failed (app continues): {e}")
        _tracer = None
        _initialized = True  # Mark as attempted to avoid retry loops
        return None


def get_tracer() -> Optional[trace.Tracer]:
    """Get tracer instance (None if tracing not initialized)."""
    return _tracer


def observed_span(name: str, attributes: dict = None):
    """
    Context manager for creating observed spans (WRAPPER-ONLY, fail-closed).
    
    GOVERNANCE:
    - Tos
import pytest
from app.tracing import init_tracing, get_tracer, observed_span, is_tracing_enabled


class TestTracingGovernance:
    """Test tracing governance (fail-closed, env var)."""
    
    def test_tracing_disabled_by_default(self, monkeypatch):
        """TRACING_ENABLED=0 by default (fail-closed)."""
        # Reset state
        from app import tracing
        tracing._initialized = False
        tracing._tracer = None
        
        # Default behavior (no env var set)
        monkeypatch.delenv("TRACING_ENABLED", raising=False)
        
        assert not is_tracing_enabled()
        tracer = init_tracing()
        assert tracer is None
    
    def test_tracing_enabled_via_env(self, monkeypatch):
        """TRACING_ENABLED=1 enables tracing."""
        # Reset state
        from app import tracing
        tracing._initialized = False
        tracing._tracer = None
        
        monkeypatch.setenv("TRACING_ENABLED", "1")
        
        assert is_tracing_enabled()
        tracer = init_tracing()
        assert tracer is not None


class TestTracingInitialization:
    """Test tracing initialization (fail-closed)."""
    
    def test_init_tracing_idempotent(self, monkeypatch):
        """Calling init_tracing() multiple times is safe."""
        monkeypatch.setenv("TRACING_ENABLED", "1")
        
        # Reset
        from app import tracing
        tracing._initialized = False
        tracing._tracer = None
        
        tracer1 = init_tracing()
        tracer2 = init_tracing()
        assert tracer1 is tracer2
    
    def test_get_tracer_before_init(self):
        """get_tracer() returns None before initialization."""
        # Reset state
        from app import tracing
        tracing._initialized = False
        tracing._tracer = None
        
        assert get_tracer() is None


class TestObservedSpan:
    """Test observed_span wrapper (wrapper-only, fail-closed)."""
    
    def test_observed_span_with_tracer(self, monkeypatch):
        """observed_span() returns context manager when tracer available."""
        monkeypatch.setenv("TRACING_ENABLED", "1")
        
        # Reset and init
        from app import tracing
        tracing._initialized = False
        tracing._tracer = None
        init_tracing()
        
        # Should not raise
        with observed_span("test_span", attributes={"test": "value"}):
            pass
    
    def test_observed_span_without_tracer(self, monkeypatch):
        """observed_span() returns no-op context when tracer unavailable."""
        monkeypatch.setenv("TRACING_ENABLED", "0")
        
        # Reset
        from app import tracing
        tracing._initialized = False
        tracing._tracer = None
        
        # Should not raise exception (fail-closed)
        with observed_span("test_span"):
            pass
    
    def test_observed_span_preserves_semantics(self, monkeypatch):
- âœ… `TRACING_ENABLED=0` confirmado (tracing desabilitado por padrÃ£o)
- âœ… Rollback testado e validado

### Rollback Execution (OBRIGATÃ“RIO)
```bash
# TESTAR ROLLBACK (executar ANTES de continuar)
# 1. Backup estado atual
cp app/tracing.py /tmp/tracing_backup.py
cp tests/test_tracing.py /tmp/test_tracing_backup.py

# 2. Simular rollback
git tag PHASE-0-COMPLETE
rm app/tracing.py tests/test_tracing.py
docker-compose -f docker-compose.tracing.yml down

# 3. Validar que backend continua funcional
pytest -q  # Should PASS (sem tracing)
curl http://localhost:8000/health  # Should return 200

# 4. Restaurar (rollback do rollback)
cp /tmp/tracing_backup.py app/tracing.py
cp /tmp/test_tracing_backup.py tests/test_tracing.py
docker-compose -f docker-compose.tracing.yml up -d

# âœ… Rollback validado
        init_tracing()
        
        # Test that return value is preserved
        def dummy_function():
            with observed_span("dummy_op"):
                return 42
        
        result = dummy_function()
        assert result == 42  # Semantics preserved= init_tracing()
        assert tracer1 is tracer2
    
    def test_get_tracer_before_init(self):
        """get_tracer() returns None before initialization."""
        # Reset state (in real test, use fixture)
        from app import tracing
        tracing._initialized = False
        tracing._tracer = None
        
        assert get_tracer() is None


class TestSpanCreation:
    """Test span creation (safe wrapper)."""
    
    def test_create_span_with_tracer(self):
        """create_span() returns context manager when tracer available."""
        init_tracing()
        
        with create_span("test_span", attributes={"test": "value"}) as span:
            # Span should be active
            pass
        
        # Span should be ended after context exit
    
    def test_create_span_without_tracer(self):
        """create_span() returns no-op context when tracer unavailable."""
        # Reset state
        from app import tracing
        tracing._tracer = None
        
        # Should not raise exception
        with create_span("test_span"):
            pass
```

### Success Criteria (FASE 0)
- âœ… Jaeger container UP (`docker ps | grep jaeger`)
- âœ… Jaeger UI acessÃ­vel (http://localhost:16686)
- âœ… MÃ³dulo `app/tracing.py` criado (SEM uso em produÃ§Ã£o ainda)
- âœ… Testes `test_tracing.py` 100% PASS
- âœ… Import test OK: `python3 -c "from app.tracing import init_tracing; print('OK')"`
- âœ… Backend continua funcionando (zero mudanÃ§as em cÃ³digo de produÃ§Ã£o)

### Rollback Plan
```bash
# Se algo falhar na FASE 0
docker-compose -f docker-compose.tracing.yml down
rm app/tracing.py tests/test_tracing.py
git checkout -- requirements.txt
```

---

## ðŸŽ¯ FASE 1 â€” INSTRUMENTAÃ‡ÃƒO MAIN (Entry Point, 3-4h)

### Objetivo
Adicionar tracing **apenas no entry point** (app/main.py), sem tocar pipeline.

### Entregas

#### 1. Instrumentar `/process` endpoint
```python
# app/main.py (adicionar import)
from app.tracing import init_tracing, create_span

# Inicializar tracing no startup
@app.on_event("startup")
async def startup_event():
    """Initialize tracing on app startup."""
    init_tracing(service_name="techno-os-backend")
    logger.info("Tracing initialized (F8.6.1)")

# Instrumentar endpoint /process
@app.post("/process")
async def process_action(
    gate_data: dict = Depends(gate_request)
):
    """Process action with tracing (F8.6.1)."""
    
    trace_id = gate_data["trace_id"]
    
    # Create root span for request
    with create_span(
        "process_action",
        attributes={
            "trace_id": trace_id,
            "action": gate_data.get("action", "unknown"),
            "context_id": gate_data.get("context_id", "unknown"),
        }
    ):
        # Original code (sem mudanÃ§as)
        result, output = run_agentic_action(
            action=gate_data["action"],
            payload=gate_data["payload"],
            trace_id=trace_id,
        )
        
        return {
            "trace_id": trace_id,
            "status": result.status,
            "result": result.dict() if result else None,
        }
```

#### 2. Testes de integraÃ§Ã£o
```python
# tests/test_tracing_integration.py
"""Integration tests for tracing (F8.6.1)."""

import pytest
from fastapi.testclient import TestClient
from app.main import app


class TestTracingIntegration:
    """Test tracing integration with /process endpoint."""
    
    def test_process_with_tracing(self):
        """Process endpoint creates spans."""
        client = TestClient(app)
        
        response = client.post(
            "/process",
            json={
                "action": "test_action",
                "context_id": "work",
                "payload": {"test": "data"}
            },
            headers={"X-API-KEY": "test_key"}
        )
        
        assert response.status_code in [200, 403]  # Either success or blocked
        
        # Span should be created (verificar via Jaeger UI manual)
    
    def test_process_without_tracing_fails_gracefully(self):
        """Process works even if tracing fails."""
        # Simular falha de tracing (mock)
        from app import tracing
        tracing._tracer = None
        
        client = TestClient(app)
        response = client.post("/process", json={...})
        
        # Should still work (fail-closed)
        assert response.status_code in [200, 403]
```

### Success Criteria (FASE 1)
- âœ… Testes `test_tracing_integration.py` 100% PASS
- âœ… Backend inicia sem erros (`uvicorn app.main:app`)
- âœ… Endpoint `/process` funciona normalmente
- âœ… Jaeger UI mostra spans (http://localhost:16686 â†’ Search â†’ Service: techno-os-backend)
- âœ… Suite completa backend: **341/341 PASS** (sem regressÃµes)

### ValidaÃ§Ã£o Manual
```bash
# 1. Enviar request
curl -X POST http://localhost:8000/process \
  -H "X-API-KEY: test_key" \
  -H "Content-Type: application/json" \
  -d '{"action": "test_action", "context_id": "work", "payload": {}}'

# 2. Verificar Jaeger UI
# Abrir http://localhost:16686
# Service: techno-os-backend
# Operation: process_action
# Deve aparecer 1 trace
```

### Rollback Plan
```bash
git diff HEAD~1 app/main.py  # Review changes
git checkout HEAD~1 -- app/main.py  # Rollback if needed
pytest  # Validate
```

---

## ðŸŽ¯ FASE 2 â€” INSTRUMENTAÃ‡ÃƒO PIPELINE (Core Logic, 4-5h)

### Objetivo
Adicionar spans no **agentic_pipeline.py** (funÃ§Ã£o principal).

### Entregas

#### 1. Instrumentar `run_agentic_action()`
```python
# app/agentic_pipeline.py (adicionar import NO TOPO)
from app.tracing import create_span

def run_agentic_action(
    action: str,
    payload: Dict[str, Any],
    trace_id: str,
    executor_id: str = "unknown",
    executor_version: str = "unknown",
) -> Tuple[ActionResult, Optional[Any]]:
    """
    Run action through governance pipeline (with tracing F8.6.1).
    """
    
    # Create span for entire pipeline execution
    with create_span(
        "agentic_action",
        attributes={
            "action": action,
            "executor_id": executor_id,
            "trace_id": trace_id,
        }
    ):
        # Step 1: Route action
        with create_span("route_action"):
            if executor_id == "unknown":
                # ... routing logic (UNCHANGED)
                pass
        
        # Step 2: Compute digests
        with create_span("compute_digests"):
            input_digest = _compute_input_digest(payload)
            # ... (UNCHANGED)
        
        # Step 3: Validate action
        with create_span("validate_action"):
            # ... action registry logic (UNCHANGED)
            pass
        
        # Step 4: Resolve executor
        with create_span("resolve_executor"):
            executor = get_executor(executor_id)
            # ... (UNCHANGED)
        
        # Step 5: Enforce limits
        with create_span("enforce_limits"):
            check_payload_limits(...)
            # ... (UNCHANGED)
        
        # Step 6: Execute
        with create_span(
            "execute_action",
            attributes={"executor_id": executor_id}
        ):
            # ... ThreadPoolExecutor logic (UNCHANGED)
            pass
        
        # Step 7: Audit
        with create_span("audit_result"):
            result = _safe_log_action_result(result)
        
        return (result, None)
```

#### 2. Testes especÃ­ficos de spans
```python
# tests/test_agentic_pipeline_tracing.py
"""Tracing tests for agentic_pipeline (F8.6.1)."""

import pytest
from app.agentic_pipeline import run_agentic_action
from app.tracing import init_tracing, get_tracer


class TestAgenticPipelineTracing:
    """Test tracing in agentic pipeline."""
    
    def test_pipeline_creates_spans(self):
        """Pipeline creates hierarchical spans."""
        init_tracing()
        tracer = get_tracer()
        assert tracer is not None
        
        # Execute action
        result, output = run_agentic_action(
            action="test_action",
            payload={"test": "data"},
            trace_id="test-trace-123",
        )
        
        # Spans should be created (verify via Jaeger)
        # Manual verification: Jaeger UI should show:
        # - agentic_action (root)
        #   - route_action
        #   - compute_digests
        #   - validate_action
        #   - resolve_executor
        #   - enforce_limits
        #   - execute_action
        #   - audit_result
```

### Success Criteria (FASE 2)
- âœ… Testes `test_agentic_pipeline.py` continuam 100% PASS (12/12)
- âœ… Testes `test_agentic_pipeline_tracing.py` 100% PASS
- âœ… Suite completa backend: **342/342 PASS** (1 novo teste, zero regressÃµes)
- âœ… Jaeger UI mostra hierarquia de spans (7 spans por execuÃ§Ã£o)
- âœ… Backend funciona normalmente (sem tracing = no-op contexts)

### ValidaÃ§Ã£o Manual
```bash
# Enviar request e verificar Jaeger
curl -X POST http://localhost:8000/process \
  -H "X-API-KEY: test_key" \
  -d '{"action": "test_action", "context_id": "work", "payload": {}}'

# Jaeger UI: Verificar trace com 7+ spans hierÃ¡rquicos
```

### Rollback Plan
```bash
git diff HEAD~1 app/agentic_pipeline.py
git checkout HEAD~1 -- app/agentic_pipeline.py
pytest tests/test_agentic_pipeline.py  # Must pass 12/12
```

---

## ðŸŽ¯ FASE 3 â€” INSTRUMENTAÃ‡ÃƒO EXECUTORS (High-Value, 3-4h)

### Objetivo
Adicionar spans nos **executors** (onde a execuÃ§Ã£o real acontece).

### Entregas

#### 1. Instrumentar `llm_executor_v1.py` (exemplo)
```python
# app/executors/llm_executor_v1.py
from app.tracing import create_span

class LLMExecutorV1(Executor):
    def execute(self, req: ActionRequest) -> Any:
        """Execute LLM action with tracing (F8.6.1)."""
        
        with create_span(
            "llm_execution",
            attributes={
                "executor": "llm_executor_v1",
                "model": self.model,
            }
        ):
            # Span for API call
            with create_span(
                "openai_api_call",
                attributes={"model": self.model}
            ):
                response = openai.ChatCompletion.create(...)
            
            # Span for validation
            with create_span("validate_response"):
                validated = self._validate_output(response)
            
            return validated
```

#### 2. Repetir para outros executors crÃ­ticos
- `composite_executor_v1.py`
- `test_executor_v1.py`
- Adicionar 1 executor por vez, validar, commit

### Success Criteria (FASE 3)
- âœ… Executor tests continuam passando (sem regressÃµes)
- âœ… Jaeger UI mostra spans detalhados de executors
- âœ… Latency breakdown visÃ­vel (API call vs validation vs etc)

---

## ðŸŽ¯ FASE 4 â€” INSTRUMENTAÃ‡ÃƒO GATE (Governance, 2-3h)

### Objetivo
Adicionar spans no **gate_engine.py** (decisÃ£o ALLOW/DENY).

### Entregas

```python
# app/gate_engine.py
from app.tracing import create_span

def evaluate_gates(...):
    """Evaluate gates with tracing (F8.6.1)."""
    
    with create_span("gate_evaluation"):
        for gate in gates:
            with create_span(
                f"gate_{gate.name}",
                attributes={"gate": gate.name}
            ):
                result = gate.fn(inp, profile)
                # ... (UNCHANGED)
```

---

## ðŸŽ¯ FASE 5 â€” CONTEXT PROPAGATION (Advanced, 2-3h)

### Objetivo
Propagar context entre threads (ThreadPoolExecutor).

### Entregas

```python
# app/agentic_pipeline.py (modificar execuÃ§Ã£o)
from opentelemetry import context

# Capture context before thread execution
ctx = context.get_current()

# Execute with context propagation
future = pool.submit(
    context.attach(ctx),  # Attach context to thread
    executor.execute,
    action_req
)
```

---

## ðŸŽ¯ FASE 6 â€” PRODUCTION HARDENING (Final, 2-3h)

### Objetivo
Configurar tracing para produÃ§Ã£o (sampling, performance tuning).

### Entregas

#### 1. Configurar sampling (evitar overhead)
```python
# app/tracing.py
from opentelemetry.sdk.trace.sampling import TraceIdRatioBased

# Sample 10% of traces (configurÃ¡vel via env var)
sampling_rate = float(os.getenv("OTEL_SAMPLING_RATE", "0.1"))
sampler = TraceIdRatioBased(sampling_rate)

provider = TracerProvider(
    resource=resource,
    sampler=sampler  # Only 10% of traces sent to Jaeger
)
```

#### 2. Configurar exporter para produÃ§Ã£o
```python
# ProduÃ§Ã£o: Use OTLP exporter (mais eficiente que Jaeger Thrift)
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter

exporter = OTLPSpanExporter(
    endpoint=os.getenv("OTEL_EXPORTER_OTLP_ENDPOINT", "http://localhost:4317")
)
```

#### 3. Adicionar health check
```python
# app/main.py
@app.get("/health")
async def health():
    """Health check with tracing status (F8.6.1)."""
    from app.tracing import get_tracer
    
    return {
        "status": "ok",
        "version": "1.0.0",
        "tracing_enabled": get_tracer() is not None
    }
```

---

## ðŸ“Š VALIDAÃ‡ÃƒO FINAL (Acceptance Criteria)

### Functional Requirements
- âœ… Backend funciona normalmente (com ou sem tracing)
- âœ… Jaeger UI mostra traces end-to-end
- âœ… Latency breakdown visÃ­vel (7+ spans por request)
- âœ… Context propagation entre threads funciona
- âœ… Sampling configurÃ¡vel (default 10%)

### Non-Functional Requirements
- âœ… Zero regressÃµes (suite completa 100% PASS)
- âœ… Overhead <5% (comparar P95 latency antes/depois)
- âœ… Fail-closed: Backend continua se tracing falhar
- âœ… Privacy: Zero PII em span attributes

### Governance Requirements
- âœ… Cada fase commitada separadamente
- âœ… Cada commit passa testes completos
- âœ… Code review humano linha-a-linha
- âœ… Rollback plan testado em cada fase
- âœ… DocumentaÃ§Ã£o atualizada (RUNBOOKs)

---

## ðŸ›¡ï¸ FAIL-CLOSED GOVERNANCE

### Checkpoint ObrigatÃ³rio (Cada Fase)
```bash
# Antes de QUALQUER commit
pytest  # Must be 100% PASS
python3 -c "from app.main import app; print('Import OK')"
curl http://localhost:8000/health  # Must return 200 OK

# Se qualquer check falhar â†’ STOP, rollback, debug
```

### Backup Before Each Phase
```bash
PHASE="F8.6.1-PHASE-N"
BK**FASE -1 â€” GovernanÃ§a** | **30min** | **ZERO** | **87.5% (prÃ©-requisito)** |
| FASE 0 â€” PreparaÃ§Ã£o | 2-3h | LOW | 87.5% â†’ 87.7% |
| FASE 1 â€” Main | 3-4h | MEDIUM | 87.7% â†’ 88.0% |
| FASE 2 â€” Pipeline | 4-5h | HIGH | 88.0% â†’ 88.3% |
| FASE 3 â€” Executors | 3-4h | MEDIUM | 88.3% â†’ 88.5% |
| FASE 4 â€” Gate | 2-3h | LOW | 88.5% â†’ 88.6% |
| FASE 5 â€” Context | 2-3h | MEDIUM | 88.6% â†’ 88.7% |
| FASE 6 â€” Hardening | 2-3h | LOW | 88.7% â†’ 88.5% (final) |
| **TOTAL** | **19-26h** | â€” | **+1.0%** |

**DistribuiÃ§Ã£o recomendada**: 3-4 dias (6h/dia), com pausas entre fases para validaÃ§Ã£o.

**IMPORTANTE**: FASE -1 Ã© **bloqueante** â€” se falhar, abortar todo process
```

---

## ðŸ“ˆ TIMELINE & ESFORÃ‡O

| Fase | EsforÃ§o | Risco | Completion |
|------|---------|-------|------------|
| FASE 0 â€” PreparaÃ§Ã£o | 2-3h | LOW | 87.5% â†’ 87.7% |
| FASE 1 â€” Main | 3-4h | MEDIUM | 87.7% â†’ 88.0% |
| FASE 2 â€” Pipeline | 4-5h | HIGH | 88.0% â†’ 88.3% |
| FASE 3 â€” Executors | 3-4h | MEDIUM | 88.3% â†’ 88.5% |
| FASE 4 â€” Gate | 2-3h | LOW | 88.5% â†’ 88.6% |
| FASE 5 â€” Context | 2-3h | MEDIUM | 88.6% â†’ 88.7% |
| FASE 6 â€” Hardening | 2-3h | LOW | 88.7% â†’ 88.5% (final) |
| **TOTAL** | **18-25h** | â€” | **+1.0%** |

**DistribuiÃ§Ã£o recomendada**: 3-4 dias (6h/dia), com pausas entre fases para validaÃ§Ã£o.

---

## ðŸš€ PRÃ“XIMO PASSO IMEDIATO

**RecomendaÃ§Ã£o**: Iniciar **FASE 0 (PreparaÃ§Ã£o)** imediatamente.

**Comando inicial**:
```bash
cd /mnt/d/Projects/techno-os-backend

# 1. Criar branch de desenvolvimento
git checkout -b feature/f8.6.1-opentelemetry-safe

# 2. Adicionar dependÃªncias
cat >> requirements.txt << EOF
# F8.6.1 - OpenTelemetry Distributed Tracing
opentelemetry-api==1.23.0
opentelemetry-sdk==1.23.0
opentelemetry-exporter-jaeger==1.23.0
opentelemetry-instrumentation==0.44b0
EOF

pip install -r requirements.txt

# 3. Deploy Jaeger
docker-compose -f docker-compose.tracing.yml up -d

# 4. Criar mÃ³dulo tracing (sem instrumentar produÃ§Ã£o ainda)
# Copiar cÃ³digo de app/tracing.py desta documentaÃ§Ã£o

# 5. Criar testes
# Copiar cÃ³digo de tests/test_tracing.py desta documentaÃ§Ã£o

# 6. Validar
pytest tests/test_tracing.py -v
python3 -c "from app.tracing import init_tracing; print('âœ… FASE 0 OK')"
```

**ApÃ³s FASE 0 completa**: Decision point para continuar FASE 1 ou revisar approach.

---

## ðŸ“š DOCUMENTAÃ‡ÃƒO COMPLEMENTAR

### RUNBOOKs a Criar
- `RUNBOOK-TRACING-F8.6.1.md` â€” Comandos operacionais Jaeger
- `TRACING-TROUBLESHOOTING.md` â€” Debug de spans, latency analysis

### ADRs a Criar
- `ADR-F8.6.1-001-MANUAL-INSTRUMENTATION.md` â€” Por quÃª manual only
- `ADR-F8.6.1-002-FAIL-CLOSED-DESIGN.md` â€” Tracing como optional feature
- `ADR-F8.6.1-003-SAMPLING-STRATEGY.md` â€” 10% sampling rate justification

---

## âœ… CONCLUSÃƒO

**Esta abordagem garante**:
1. âœ… Zero automation (manual only)
2. âœ… Incremental rollout (6 fases isoladas)
3. âœ… Test-first (validaÃ§Ã£o em cada fase)
4. âœ… Fail-closed (backend continua se tracing falhar)
5. âœ… Rollback ready (backups + git tags)
6. âœ… Code review humano (linha-a-linha)

**DiferenÃ§a vs incidente F8.6.1**:
- âŒ ANTES: Script automatizado â†’ 174 arquivos quebrados â†’ NameError
- âœ… AGORA: Manual, incremental, testado â†’ Zero risco de quebra catastrÃ³fica

**ConfianÃ§a**: 95% (baseado em governanÃ§a fail-closed + liÃ§Ãµes aprendidas)

---

**FIM DO PLANO**
