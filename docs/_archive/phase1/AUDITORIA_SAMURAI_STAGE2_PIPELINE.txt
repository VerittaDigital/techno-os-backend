================================================================================
AUDITORIA SAMURAI — STAGE 2: PIPELINE EXECUTION ANALYSIS
TECHNO OS BACKEND (AGENTIC VERITTÀ)
================================================================================

DATA: 21 de dezembro de 2025
MODO: Adversarial, técnico, executivo
ESCOPO: Análise profunda de agentic_pipeline.py e routing logic
AUDIÊNCIA: Arquitetos sêniores e auditores de governança

AVISO: Este documento analisa comportamento de execução do pipeline.
NÃO contém propostas de correção ou discussão de testes.

================================================================================
1. PIPELINE OVERVIEW
================================================================================

FUNÇÃO ANALISADA: run_agentic_action()

LOCALIZAÇÃO: app/agentic_pipeline.py (linhas ~115-481)

SIGNATURE:
def run_agentic_action(
    action: str,
    payload: Dict[str, Any],
    trace_id: str,
    executor_id: str = "unknown",
    executor_version: str = "unknown",
) -> Tuple[ActionResult, Optional[Any]]

RETURN CONTRACT:
  - Sempre retorna (ActionResult, None)
  - Output bruto NUNCA retornado (segundo elemento sempre None)
  - ActionResult contém status, reason_codes, digests, trace_id

EXECUTION MODEL:
  - Síncrono (sem async)
  - Linear (sem paralelismo)
  - Fail-fast (primeiro erro bloqueia)
  - Stateless (sem side-effects declarado)

TOTAL DE STEPS: 8 (numeração no código: 1, 2, 3, 3A, 3B, 4, 4A, 4B, 5, 6, 7)


================================================================================
2. STEP-BY-STEP EXECUTION ANALYSIS
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 1: ACTION ROUTING                                                      │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Resolver executor_id a partir de action, se não foi explicitamente fornecido.

INPUTS:
  - action: str
  - executor_id: str (default "unknown")
  - executor_version: str (default "unknown")

LOGIC:
if executor_id == "unknown":
    try:
        # Tenta router determinístico
        executor_id = route_action_deterministic(action)
        action_routed = True
    except Exception:
        # Fallback: busca em action_registry
        try:
            registry = get_action_registry()
            action_meta = registry.actions.get(action)
            if action_meta and isinstance(action_meta, dict):
                executor_id = action_meta.get("executor", "unknown")
                action_routed = (executor_id != "unknown")
        except Exception:
            pass

OUTPUTS:
  - executor_id: str (resolvido ou ainda "unknown")
  - action_routed: bool (flag interna)

FAILURE MODES:
  1. route_action_deterministic() raises UnknownActionError
     → Capturado, tenta fallback
  2. get_action_registry() raises Exception
     → Capturado, executor_id permanece "unknown"
  3. action_meta não tem field "executor"
     → executor_id permanece "unknown"
  4. action_meta["executor"] é "unknown"
     → action_routed = False

IMPLICIT ASSUMPTIONS:
  - route_action_deterministic() é fonte primária de routing
  - action_registry é fallback
  - Exceptions em routing são não-fatais (silent failure)
  - executor_id "unknown" é válido (não bloqueia ainda)

CONVENTION VS ENFORCEMENT:
  - CONVENTION: action_meta deve ter field "executor"
  - CONVENTION: executor_id deve ser string
  - ENFORCEMENT: None (field pode estar ausente)

SILENT FAILURE RISKS:
  ⚠️ Se routing falha silenciosamente, executor_id = "unknown"
  ⚠️ Erro só será detectado em Step 4 (executor resolution)
  ⚠️ Exceções em routing são suprimidas (bare except)
  ⚠️ Sem logging de fallback ou routing failure


┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 2: INPUT DIGEST COMPUTATION                                            │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Computar SHA256 digest de payload para auditability e privacidade.

INPUTS:
  - payload: Dict[str, Any]

LOGIC:
input_digest = _compute_input_digest(payload)

_compute_input_digest():
    try:
        canonical = json.dumps(payload, sort_keys=True, separators=(",", ":"), ensure_ascii=False)
        return hashlib.sha256(canonical.encode("utf-8")).hexdigest()
    except (TypeError, ValueError):
        return None

OUTPUTS:
  - input_digest: Optional[str]
    • SHA256 hex string (64 chars) se JSON-serializável
    • None se não-serializável

FAILURE MODES:
  1. Payload contém objeto não-serializável (e.g., class instance)
     → Retorna None
  2. Payload contém circular reference
     → Retorna None
  3. json.dumps() raises TypeError (unsupported type)
     → Retorna None
  4. json.dumps() raises ValueError (circular reference ou NaN/Infinity)
     → Retorna None

IMMEDIATE ACTION ON FAILURE:
if input_digest is None:
    status = "BLOCKED"
    reason_codes = ["NON_JSON_PAYLOAD"]
    # Cria ActionResult
    # log_action_result(result)
    return (result, None)

IMPLICIT ASSUMPTIONS:
  - Payload deveria ser JSON-serializável
  - None é marcador de falha
  - NON_JSON_PAYLOAD é reason_code adequado

CONVENTION VS ENFORCEMENT:
  - ENFORCEMENT: ✓ Payload não-serializável bloqueia execução
  - ENFORCEMENT: ✓ input_digest é obrigatório para continuar

SILENT FAILURE RISKS:
  ⚠️ TypeError e ValueError são tratados igualmente (sem distinção)
  ⚠️ Sem indicação de QUAL campo causou problema
  ⚠️ Circular references não são diferenciados de tipos inválidos


┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 3: ACTION REGISTRY LOOKUP                                              │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Buscar metadados da ação no action registry para validação AG-03.

INPUTS:
  - action: str

LOGIC:
action_meta = None
try:
    registry = get_action_registry()
    action_meta = registry.actions.get(action)
except Exception:
    # Registry not available - proceed with routing only
    pass

OUTPUTS:
  - action_meta: Optional[dict | ActionMeta]
    • dict com metadados se ação existe
    • None se ação não existe ou registry inacessível

FAILURE MODES:
  1. get_action_registry() raises Exception
     → action_meta = None, continua execução
  2. registry.actions.get(action) retorna None
     → action_meta = None
  3. action_meta existe mas tipo inválido
     → Não validado aqui, pode causar erro em steps seguintes

IMPLICIT ASSUMPTIONS:
  - Registry pode estar indisponível (não é fatal)
  - None é estado válido para action_meta
  - Validação de existência de ação é feita em Step 3A

CONVENTION VS ENFORCEMENT:
  - CONVENTION: Registry deve estar disponível
  - CONVENTION: action_meta deve ser dict ou ActionMeta
  - ENFORCEMENT: None (exceptions suprimidas)

SILENT FAILURE RISKS:
  ⚠️ Exception em get_action_registry() é silenciosamente ignorada
  ⚠️ Sem logging de registry unavailable
  ⚠️ Pipeline continua com action_meta = None
  ⚠️ Diferença entre "ação não existe" e "registry inacessível" é perdida


┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 3A: ACTION EXISTENCE VALIDATION                                        │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Validar que ação existe no registry OU foi roteada com sucesso.

INPUTS:
  - action_meta: Optional[dict | ActionMeta]
  - action_routed: bool (de Step 1)

LOGIC:
if action_meta is None and not action_routed:
    # Action not in registry and not routed successfully
    status = "BLOCKED"
    reason_codes = ["ACTION_UNKNOWN"]
    # Cria ActionResult
    # log_action_result(result)
    return (result, None)

OUTPUTS:
  - Continua execução OU retorna BLOCKED

FAILURE MODES:
  1. action_meta é None E action_routed é False
     → BLOCKED com ACTION_UNKNOWN

IMPLICIT ASSUMPTIONS:
  - Se action_routed=True, ação é válida mesmo sem metadata
  - Se action_meta existe, ação é válida mesmo se não roteada
  - OR logic: basta UMA condição ser verdadeira

CONVENTION VS ENFORCEMENT:
  - ENFORCEMENT: ✓ Ação deve existir em registry OU ter sido roteada
  - WEAKNESS: Routing success não garante executor existe

SILENT FAILURE RISKS:
  ⚠️ action_routed=True mas executor pode não existir (detectado depois)
  ⚠️ Lógica OR permite bypass: se routing sucede, metadata não importa
  ⚠️ Se routing falha E metadata existe, metadata é ignorada


┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 3B: ACTION VERSION VALIDATION (AG-03)                                  │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Validar que ação tem action_version válido (semver) para ações não-legacy.

INPUTS:
  - action_meta: Optional[dict | ActionMeta]
  - action: str (para checar LEGACY_ACTIONS)

LOGIC:
if action_meta is not None:
    action_version = action_meta.get("action_version")
    if action_version is None:
        if action not in LEGACY_ACTIONS:
            status = "BLOCKED"
            reason_codes = ["ACTION_VERSION_MISSING"]
            return (result, None)
    elif not _is_valid_semver(action_version):
        status = "BLOCKED"
        reason_codes = ["ACTION_VERSION_INVALID"]
        return (result, None)

OUTPUTS:
  - Continua execução OU retorna BLOCKED

FAILURE MODES:
  1. action_version é None E action não é legacy
     → BLOCKED com ACTION_VERSION_MISSING
  2. action_version existe mas não é semver (X.Y.Z)
     → BLOCKED com ACTION_VERSION_INVALID

IMPLICIT ASSUMPTIONS:
  - action_meta pode ser dict (usa .get()) ou objeto (assume atributo)
  - LEGACY_ACTIONS = {"process"} é hardcoded
  - Ações legacy não precisam de versioning
  - Semver é sempre X.Y.Z (3 componentes numéricos)

CONVENTION VS ENFORCEMENT:
  - ENFORCEMENT: ✓ action_version obrigatório para não-legacy
  - ENFORCEMENT: ✓ action_version deve ser semver válido
  - CONVENTION: LEGACY_ACTIONS set é hardcoded (não configurável)

SILENT FAILURE RISKS:
  ⚠️ Se action_meta é None, validação é SKIPPED
  ⚠️ Legacy actions nunca validadas (podem ter version inválida)
  ⚠️ Sem validação de action_version contra executor_version ainda


┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 4: EXECUTOR RESOLUTION                                                 │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Obter instância de executor e extrair sua versão.

INPUTS:
  - executor_id: str (de Step 1)

LOGIC:
executor = None
try:
    executor = get_executor(executor_id)
    # Ensure executor_version is a string (not MagicMock)
    exec_version_raw = getattr(executor, "version", None)
    if isinstance(exec_version_raw, str):
        executor_version = exec_version_raw
    else:
        executor_version = None
except UnknownExecutorError:
    status = "BLOCKED"
    reason_codes = ["EXECUTOR_NOT_FOUND"]
    return (result, None)

OUTPUTS:
  - executor: Executor instance OU None
  - executor_version: Optional[str]

FAILURE MODES:
  1. executor_id não existe em registry
     → UnknownExecutorError → BLOCKED com EXECUTOR_NOT_FOUND
  2. executor.version não é string (e.g., MagicMock, int, None)
     → executor_version = None (não bloqueia aqui)
  3. executor.version atributo ausente
     → getattr retorna None, executor_version = None

IMPLICIT ASSUMPTIONS:
  - get_executor() sempre retorna Executor ou raises UnknownExecutorError
  - executor.version deve ser string
  - Comentário "not MagicMock" indica testes influenciaram código
  - executor_version = None é válido (não bloqueia aqui)

CONVENTION VS ENFORCEMENT:
  - ENFORCEMENT: ✓ executor_id deve existir em registry
  - CONVENTION: executor.version deve ser string
  - ENFORCEMENT: None (executor_version=None não bloqueia aqui)

SILENT FAILURE RISKS:
  ⚠️ executor.version pode ser None e execução continua
  ⚠️ Validação de version é adiada para Step 4A
  ⚠️ Se version ausente, min_executor_version check pode falhar
  ⚠️ Comentário sobre MagicMock indica test pollution no código produção


┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 4A: EXECUTOR VERSION VALIDATION (AG-03)                                │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Validar que executor_version satisfaz min_executor_version da ação.

INPUTS:
  - action_meta: Optional[dict | ActionMeta]
  - action: str (para checar LEGACY_ACTIONS)
  - executor_version: Optional[str]

LOGIC:
if action_meta and action not in LEGACY_ACTIONS:
    min_executor_version = action_meta.get("min_executor_version")
    if min_executor_version is not None:
        if executor_version is None:
            status = "BLOCKED"
            reason_codes = ["EXECUTOR_VERSION_MISSING"]
            return (result, None)
        else:
            # Use semver comparison instead of string comparison
            try:
                if _compare_semver(executor_version, min_executor_version) < 0:
                    status = "BLOCKED"
                    reason_codes = ["EXECUTOR_VERSION_INCOMPATIBLE"]
                    return (result, None)
            except ValueError:
                # If version comparison fails, treat as incompatible
                status = "BLOCKED"
                reason_codes = ["EXECUTOR_VERSION_INCOMPATIBLE"]
                return (result, None)

OUTPUTS:
  - Continua execução OU retorna BLOCKED

FAILURE MODES:
  1. min_executor_version definido mas executor_version é None
     → BLOCKED com EXECUTOR_VERSION_MISSING
  2. executor_version < min_executor_version (semver)
     → BLOCKED com EXECUTOR_VERSION_INCOMPATIBLE
  3. _compare_semver() raises ValueError (version inválida)
     → BLOCKED com EXECUTOR_VERSION_INCOMPATIBLE

IMPLICIT ASSUMPTIONS:
  - Legacy actions não precisam de version check
  - min_executor_version sendo None significa "any version OK"
  - ValueError em semver comparison é tratado como incompatível
  - packaging.version.Version valida formato

CONVENTION VS ENFORCEMENT:
  - ENFORCEMENT: ✓ executor_version obrigatório se min_executor_version definido
  - ENFORCEMENT: ✓ Comparação semver correta (B1-FIX)
  - ENFORCEMENT: ✓ Versions inválidas tratadas como incompatíveis
  - SKIP: Legacy actions e actions sem min_executor_version

SILENT FAILURE RISKS:
  ⚠️ Se action_meta é None, validação é SKIPPED
  ⚠️ Se action é legacy, validação é SKIPPED
  ⚠️ Se min_executor_version é None, qualquer version passa
  ⚠️ ValueError não distingue qual version é inválida (executor ou min)


┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 4B: EXECUTOR CAPABILITIES VALIDATION (AG-03)                           │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Validar que executor possui todas as capabilities requeridas pela ação.

INPUTS:
  - action_meta: Optional[dict | ActionMeta]
  - action: str (para checar LEGACY_ACTIONS)
  - executor: Executor instance

LOGIC:
if action_meta and action not in LEGACY_ACTIONS:
    required_capabilities = action_meta.get("required_capabilities", [])
    if required_capabilities:
        # Get capabilities attribute
        executor_capabilities = getattr(executor, "capabilities", None)
        
        # If executor has no capabilities attribute at all → MISSING
        # Check for None or non-list types (e.g. MagicMock)
        if executor_capabilities is None or not isinstance(executor_capabilities, (list, tuple, set)):
            status = "BLOCKED"
            reason_codes = ["EXECUTOR_CAPABILITY_MISSING"]
            return (result, None)
        
        # If executor has capabilities but insufficient → MISMATCH
        normalized_executor_caps = _normalize_capabilities(executor_capabilities)
        normalized_required_caps = _normalize_capabilities(required_capabilities)

        missing_capabilities = set(normalized_required_caps) - set(normalized_executor_caps)
        if missing_capabilities:
            status = "BLOCKED"
            reason_codes = ["EXECUTOR_CAPABILITY_MISMATCH"]
            return (result, None)

OUTPUTS:
  - Continua execução OU retorna BLOCKED

FAILURE MODES:
  1. executor.capabilities ausente (None)
     → BLOCKED com EXECUTOR_CAPABILITY_MISSING
  2. executor.capabilities não é list/tuple/set (e.g., MagicMock, string)
     → BLOCKED com EXECUTOR_CAPABILITY_MISSING
  3. executor.capabilities existe mas faltam capabilities
     → BLOCKED com EXECUTOR_CAPABILITY_MISMATCH

IMPLICIT ASSUMPTIONS:
  - Legacy actions não precisam de capability check
  - required_capabilities vazio significa "no requirements"
  - Capabilities são normalizadas: uppercase, deduplicated, sorted
  - MISSING (ausência total) vs MISMATCH (presença parcial) são distintos

CONVENTION VS ENFORCEMENT:
  - ENFORCEMENT: ✓ executor.capabilities deve ser list/tuple/set
  - ENFORCEMENT: ✓ Todas required_capabilities devem estar presentes
  - ENFORCEMENT: ✓ Normalização garante comparação case-insensitive
  - SKIP: Legacy actions e actions sem required_capabilities

SILENT FAILURE RISKS:
  ⚠️ Se action_meta é None, validação é SKIPPED
  ⚠️ Se action é legacy, validação é SKIPPED
  ⚠️ Se required_capabilities é [], validação é SKIPPED
  ⚠️ Comentário sobre MagicMock indica test pollution
  ⚠️ Capabilities podem estar presentes mas não funcionais (não verificado)


┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 5: PAYLOAD LIMITS ENFORCEMENT                                          │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Validar que payload não excede limites de segurança do executor.

INPUTS:
  - payload: Dict[str, Any]
  - executor: Executor instance
  - executor.limits: ExecutorLimits

LOGIC:
try:
    from app.payload_limits import check_payload_limits, LimitExceeded
    check_payload_limits(
        payload,
        max_bytes=executor.limits.max_payload_bytes,
        max_depth_limit=executor.limits.max_depth,
        max_list_limit=executor.limits.max_list_items,
    )
except TypeError:
    # Non-JSON-serializable payload
    status = "BLOCKED"
    reason_codes = ["NON_JSON_PAYLOAD"]
    return (result, None)
except LimitExceeded:
    status = "BLOCKED"
    reason_codes = ["LIMIT_EXCEEDED"]
    return (result, None)

OUTPUTS:
  - Continua execução OU retorna BLOCKED

FAILURE MODES:
  1. Payload exceeds max_payload_bytes
     → LimitExceeded → BLOCKED com LIMIT_EXCEEDED
  2. Payload exceeds max_depth
     → LimitExceeded → BLOCKED com LIMIT_EXCEEDED
  3. Payload has list exceeding max_list_items
     → LimitExceeded → BLOCKED com LIMIT_EXCEEDED
  4. Payload não-serializável (TypeError)
     → BLOCKED com NON_JSON_PAYLOAD

IMPLICIT ASSUMPTIONS:
  - executor.limits existe e tem os 3 atributos
  - check_payload_limits() usa travessia iterativa (não recursiva)
  - TypeError indica payload não-serializável
  - LimitExceeded é generic (não diz QUAL limite foi violado)

CONVENTION VS ENFORCEMENT:
  - ENFORCEMENT: ✓ Limites são obrigatórios e verificados
  - ENFORCEMENT: ✓ Travessia iterativa previne stack overflow
  - WEAKNESS: reason_codes não especifica qual limite foi violado

SILENT FAILURE RISKS:
  ⚠️ TypeError aqui vs TypeError em Step 2: payload pode mutar entre steps
  ⚠️ LIMIT_EXCEEDED não diz se foi bytes, depth, ou list_items
  ⚠️ executor.limits pode ter valores absurdos (não validados)
  ⚠️ Se executor.limits ausente, AttributeError não capturado


┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 6: EXECUTOR EXECUTION WITH PRE-AUDIT (B3-FIX)                          │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Executar ação via executor com auditoria pré e pós execução.

INPUTS:
  - action: str
  - payload: Dict[str, Any]
  - trace_id: str
  - executor: Executor instance
  - executor_id: str
  - executor_version: str
  - input_digest: str

LOGIC — PRE-AUDIT:
# PRE-AUDIT: Log execution attempt BEFORE executor runs
pre_audit_result = ActionResult(
    action=action,
    executor_id=executor_id,
    executor_version=executor_version,
    status="PENDING",  # Special: indicates execution was attempted
    reason_codes=["EXECUTION_ATTEMPT"],  # Marker for pre-audit
    input_digest=input_digest,
    output_digest=None,  # Not known yet
    trace_id=trace_id,
    ts_utc=datetime.now(timezone.utc),
)
log_action_result(pre_audit_result)

LOGIC — EXECUTION:
try:
    # Create ActionRequest
    action_req = ActionRequest(
        action=action,
        payload=payload,
        trace_id=trace_id,
    )
    output = executor.execute(action_req)
except TimeoutError:
    # Simulated timeout (for tests; real timeout requires async)
    status = "FAILED"
    reason_codes = ["EXECUTOR_TIMEOUT"]
    log_action_result(result)
    return (result, None)
except Exception as e:
    # Any other exception during execution
    status = "FAILED"
    reason_codes = ["EXECUTOR_EXCEPTION"]
    log_action_result(result)
    return (result, None)

OUTPUTS:
  - PRE-AUDIT: ActionResult(PENDING) logado
  - output: Any (resultado de executor.execute())
  - OU: retorna (ActionResult(FAILED), None)

FAILURE MODES:
  1. executor.execute() raises TimeoutError
     → FAILED com EXECUTOR_TIMEOUT
  2. executor.execute() raises qualquer Exception
     → FAILED com EXECUTOR_EXCEPTION
  3. executor.execute() retorna sem exceção
     → Continua para Step 7

IMPLICIT ASSUMPTIONS:
  - PRE-AUDIT garante auditabilidade mesmo se executor tiver side-effects
  - TimeoutError é gerado por executor (mas comentário diz "simulated")
  - Qualquer Exception é erro de executor (não de pipeline)
  - output pode ser Any (validação de tipo adiada)
  - executor.execute() NÃO tem side-effects (declarado, não enforced)

CONVENTION VS ENFORCEMENT:
  - ENFORCEMENT: ✓ PRE-AUDIT sempre logado antes de execução
  - ENFORCEMENT: ✓ Exceções sempre mapeadas para FAILED
  - CONVENTION: executor.execute() deve ser determinístico
  - CONVENTION: executor.execute() deve ser side-effect free
  - CONVENTION: TimeoutError deve ser gerado pelo executor

SILENT FAILURE RISKS:
  ⚠️ TimeoutError NUNCA é realmente gerado (timeout não enforced)
  ⚠️ Executor pode ter side-effects e pipeline não detecta
  ⚠️ Exception info (e) não é logada (sem stack trace)
  ⚠️ Bare except Exception captura tudo (incluindo KeyboardInterrupt se não tratado)
  ⚠️ Diferença entre "executor bug" e "executor falhou legitimamente" é perdida
  ⚠️ output pode ser inválido (e.g., non-serializable) e só é detectado em Step 7


┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 7: POST-AUDIT AND SUCCESS                                              │
└─────────────────────────────────────────────────────────────────────────────┘

PURPOSE:
Computar output_digest e logar resultado de sucesso.

INPUTS:
  - output: Any (de Step 6)
  - action, executor_id, executor_version, input_digest, trace_id

LOGIC:
# Step 7: Success — Compute output digest and return
output_digest = _compute_output_digest(output)
status = "SUCCESS"
reason_codes = []
result = ActionResult(
    action=action,
    executor_id=executor_id,
    executor_version=executor_version,
    status=status,
    reason_codes=reason_codes,
    input_digest=input_digest,
    output_digest=output_digest,
    trace_id=trace_id,
    ts_utc=datetime.now(timezone.utc),
)
log_action_result(result)
return (result, None)  # Raw output never returned (privacy by design)

_compute_output_digest():
    if output is None:
        return None
    try:
        canonical = json.dumps(output, sort_keys=True, separators=(",", ":"), ensure_ascii=False)
        return hashlib.sha256(canonical.encode("utf-8")).hexdigest()
    except TypeError:
        # Non-serializable output
        return None

OUTPUTS:
  - POST-AUDIT: ActionResult(SUCCESS) logado
  - Return: (ActionResult, None)

FAILURE MODES:
  1. output não-serializável
     → output_digest = None (MAS status = SUCCESS)
  2. output é None
     → output_digest = None (normal)
  3. json.dumps() raises TypeError
     → output_digest = None (silencioso)

IMPLICIT ASSUMPTIONS:
  - output_digest = None é válido para SUCCESS
  - Output bruto NUNCA deve ser retornado (privacy)
  - reason_codes vazio para SUCCESS é normal
  - ts_utc captura tempo de conclusão (não início)

CONVENTION VS ENFORCEMENT:
  - ENFORCEMENT: ✓ Output bruto nunca retornado
  - ENFORCEMENT: ✓ POST-AUDIT sempre logado
  - WEAKNESS: output_digest pode ser None mesmo em SUCCESS
  - WEAKNESS: Sem validação de output antes de digest

SILENT FAILURE RISKS:
  ⚠️ output não-serializável resulta em output_digest=None mas status=SUCCESS
  ⚠️ Cliente não sabe que output foi inválido
  ⚠️ Diferença entre "output é None" e "output não-serializável" é perdida
  ⚠️ Executor pode retornar garbage e pipeline aceita como SUCCESS


================================================================================
3. PIPELINE EXECUTION FLOW DIAGRAM
================================================================================

START: run_agentic_action(action, payload, trace_id, executor_id, executor_version)
  │
  ├─ STEP 1: Routing
  │    ├─ IF executor_id == "unknown"
  │    │    ├─ TRY: route_action_deterministic(action)
  │    │    │    └─ CATCH: fallback to action_registry.actions[action]["executor"]
  │    │    │         └─ CATCH: executor_id remains "unknown"
  │    │    └─ SET: action_routed = True/False
  │    └─ CONTINUE
  │
  ├─ STEP 2: Input Digest
  │    ├─ input_digest = _compute_input_digest(payload)
  │    ├─ IF input_digest is None
  │    │    └─ RETURN: BLOCKED + NON_JSON_PAYLOAD
  │    └─ CONTINUE
  │
  ├─ STEP 3: Action Registry Lookup
  │    ├─ TRY: action_meta = get_action_registry().actions[action]
  │    │    └─ CATCH: action_meta = None
  │    └─ CONTINUE
  │
  ├─ STEP 3A: Action Existence
  │    ├─ IF action_meta is None AND NOT action_routed
  │    │    └─ RETURN: BLOCKED + ACTION_UNKNOWN
  │    └─ CONTINUE
  │
  ├─ STEP 3B: Action Version
  │    ├─ IF action_meta is not None
  │    │    ├─ IF action_version is None AND action NOT in LEGACY_ACTIONS
  │    │    │    └─ RETURN: BLOCKED + ACTION_VERSION_MISSING
  │    │    ├─ IF action_version invalid semver
  │    │    │    └─ RETURN: BLOCKED + ACTION_VERSION_INVALID
  │    │    └─ CONTINUE
  │    └─ CONTINUE
  │
  ├─ STEP 4: Executor Resolution
  │    ├─ TRY: executor = get_executor(executor_id)
  │    │    └─ CATCH UnknownExecutorError:
  │    │         └─ RETURN: BLOCKED + EXECUTOR_NOT_FOUND
  │    ├─ executor_version = getattr(executor, "version", None)
  │    │    └─ IF NOT isinstance(str): executor_version = None
  │    └─ CONTINUE
  │
  ├─ STEP 4A: Executor Version
  │    ├─ IF action_meta AND action NOT in LEGACY_ACTIONS
  │    │    ├─ IF min_executor_version is not None
  │    │    │    ├─ IF executor_version is None
  │    │    │    │    └─ RETURN: BLOCKED + EXECUTOR_VERSION_MISSING
  │    │    │    ├─ TRY: IF executor_version < min_executor_version (semver)
  │    │    │    │    └─ RETURN: BLOCKED + EXECUTOR_VERSION_INCOMPATIBLE
  │    │    │    └─ CATCH ValueError:
  │    │    │         └─ RETURN: BLOCKED + EXECUTOR_VERSION_INCOMPATIBLE
  │    │    └─ CONTINUE
  │    └─ CONTINUE
  │
  ├─ STEP 4B: Executor Capabilities
  │    ├─ IF action_meta AND action NOT in LEGACY_ACTIONS
  │    │    ├─ IF required_capabilities not empty
  │    │    │    ├─ executor_capabilities = getattr(executor, "capabilities", None)
  │    │    │    ├─ IF capabilities is None OR NOT list/tuple/set
  │    │    │    │    └─ RETURN: BLOCKED + EXECUTOR_CAPABILITY_MISSING
  │    │    │    ├─ missing = required - executor_capabilities
  │    │    │    ├─ IF missing not empty
  │    │    │    │    └─ RETURN: BLOCKED + EXECUTOR_CAPABILITY_MISMATCH
  │    │    │    └─ CONTINUE
  │    │    └─ CONTINUE
  │    └─ CONTINUE
  │
  ├─ STEP 5: Payload Limits
  │    ├─ TRY: check_payload_limits(payload, executor.limits)
  │    │    ├─ CATCH TypeError:
  │    │    │    └─ RETURN: BLOCKED + NON_JSON_PAYLOAD
  │    │    └─ CATCH LimitExceeded:
  │    │         └─ RETURN: BLOCKED + LIMIT_EXCEEDED
  │    └─ CONTINUE
  │
  ├─ STEP 6a: PRE-AUDIT
  │    ├─ pre_audit = ActionResult(status=PENDING, reason_codes=[EXECUTION_ATTEMPT])
  │    ├─ log_action_result(pre_audit)
  │    └─ CONTINUE
  │
  ├─ STEP 6b: Execution
  │    ├─ action_req = ActionRequest(action, payload, trace_id)
  │    ├─ TRY: output = executor.execute(action_req)
  │    │    ├─ CATCH TimeoutError:
  │    │    │    └─ RETURN: FAILED + EXECUTOR_TIMEOUT
  │    │    └─ CATCH Exception:
  │    │         └─ RETURN: FAILED + EXECUTOR_EXCEPTION
  │    └─ CONTINUE
  │
  └─ STEP 7: POST-AUDIT
       ├─ output_digest = _compute_output_digest(output)
       ├─ result = ActionResult(status=SUCCESS, output_digest=...)
       ├─ log_action_result(result)
       └─ RETURN: (result, None)

END


================================================================================
4. IMPLICIT ASSUMPTIONS IN PIPELINE
================================================================================

ASSUMPTION 1: EXECUTOR DETERMINISM
  Location: Step 6
  Assumption: executor.execute() é determinístico
  Reality: Não enforced, depende de convenção
  Risk: Executor pode usar random, timestamp, network call

ASSUMPTION 2: EXECUTOR SIDE-EFFECT FREE
  Location: Step 6
  Assumption: executor.execute() não tem side-effects
  Reality: Não enforced, B3-FIX mitiga com PRE-AUDIT
  Risk: Executor pode enviar webhook, escrever DB, chamar API

ASSUMPTION 3: TIMEOUT IS GENERATED BY EXECUTOR
  Location: Step 6
  Assumption: executor.execute() raises TimeoutError se exceder limite
  Reality: Comentário diz "simulated", timeout_ms não enforced
  Risk: Executor pode rodar indefinidamente

ASSUMPTION 4: REGISTRY ALWAYS AVAILABLE
  Location: Step 3
  Assumption: get_action_registry() retorna registry válido
  Reality: Exception silenciosamente capturada, action_meta = None
  Risk: Registry down não é detectado, diferente de "ação não existe"

ASSUMPTION 5: ROUTING IS SINGLE-SOURCE
  Location: Step 1
  Assumption: route_action_deterministic() é fonte primária
  Reality: Fallback para action_registry.actions["executor"]
  Risk: Inconsistência entre router e registry não detectada

ASSUMPTION 6: LEGACY ACTIONS ARE SAFE
  Location: Steps 3B, 4A, 4B
  Assumption: Ações legacy não precisam de AG-03 validation
  Reality: LEGACY_ACTIONS = {"process"} hardcoded
  Risk: Legacy actions podem ter incompatibilidades não detectadas

ASSUMPTION 7: OUTPUT IS VALID
  Location: Step 7
  Assumption: executor.execute() retorna output válido
  Reality: output pode ser qualquer tipo, inclusive não-serializável
  Risk: output_digest = None mas status = SUCCESS (inconsistente)

ASSUMPTION 8: EXCEPTIONS ARE EXECUTOR ERRORS
  Location: Step 6
  Assumption: Exception em executor.execute() é erro do executor
  Reality: Pode ser bug de pipeline, payload inválido, etc.
  Risk: Todos os erros mapeados genericamente para EXECUTOR_EXCEPTION

ASSUMPTION 9: EXECUTOR.LIMITS EXISTS
  Location: Step 5
  Assumption: executor tem atributo limits com os 3 fields
  Reality: Protocolo Executor define, mas não enforced
  Risk: AttributeError se executor não tem limits

ASSUMPTION 10: ACTION_META TYPE IS VALID
  Location: Steps 3B, 4A, 4B
  Assumption: action_meta é dict ou ActionMeta com fields esperados
  Reality: .get() é usado (assume dict), pode ser objeto
  Risk: AttributeError se action_meta não tem .get() method

ASSUMPTION 11: TRACE_ID IS UNIQUE
  Location: All steps
  Assumption: trace_id identifica uniquely esta execução
  Reality: Gerado como UUID em main.py
  Risk: UUID collision (extremamente raro mas possível)

ASSUMPTION 12: TS_UTC IS ACCURATE
  Location: Step 6a, Step 7
  Assumption: datetime.now(timezone.utc) captura tempo correto
  Reality: Depende de system clock
  Risk: Clock drift, timezone issues, time travel (se clock ajustado)

ASSUMPTION 13: JSON.DUMPS IS DETERMINISTIC
  Location: Step 2, Step 7
  Assumption: json.dumps(sort_keys=True) produz output determinístico
  Reality: Python dict iteration é determinística desde 3.7+
  Risk: Se payload tem objetos com __dict__ não-ordenado, pode variar

ASSUMPTION 14: PAYLOAD IS IMMUTABLE
  Location: Step 2 → Step 5 → Step 6
  Assumption: payload não muda entre steps
  Reality: payload é Dict mutável, passado por referência
  Risk: payload pode mutar entre Step 2 (digest) e Step 6 (execute)

ASSUMPTION 15: ACTION_ROUTED FLAG IS RELIABLE
  Location: Step 1 → Step 3A
  Assumption: action_routed=True significa executor existe
  Reality: Routing success não valida existência de executor
  Risk: executor pode não existir (detectado em Step 4)


================================================================================
5. CONVENTION VS ENFORCEMENT ANALYSIS
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│ ENFORCED (Hard Failures)                                                    │
└─────────────────────────────────────────────────────────────────────────────┘

✓ Payload deve ser JSON-serializável (Step 2)
✓ Action deve existir em registry OU ter sido roteada (Step 3A)
✓ action_version deve ser semver válido (Step 3B, non-legacy)
✓ Executor deve existir em registry (Step 4)
✓ executor_version >= min_executor_version (Step 4A, non-legacy)
✓ Executor deve ter required_capabilities (Step 4B, non-legacy)
✓ Payload deve respeitar limites (Step 5)
✓ PRE-AUDIT deve ser logado antes de execução (Step 6a)
✓ POST-AUDIT deve ser logado após execução (Step 7)
✓ Output bruto nunca retornado (Step 7)


┌─────────────────────────────────────────────────────────────────────────────┐
│ CONVENTION (Soft Expectations)                                              │
└─────────────────────────────────────────────────────────────────────────────┘

⚠️ Executor deve ser determinístico (Step 6)
   Reality: Não verificado, depende de implementação

⚠️ Executor deve ser side-effect free (Step 6)
   Reality: Não verificado, B3-FIX mitiga com PRE-AUDIT

⚠️ Executor deve respeitar timeout_ms (Step 6)
   Reality: Timeout não enforced, TimeoutError nunca gerado

⚠️ executor.version deve ser string (Step 4)
   Reality: Verificado tipo mas None aceito

⚠️ executor.capabilities deve ser list/tuple/set (Step 4B)
   Reality: Verificado apenas se required_capabilities não vazio

⚠️ action_meta.get() deve funcionar (Steps 3B, 4A, 4B)
   Reality: Assume dict-like, pode ser objeto

⚠️ Output deve ser JSON-serializável (Step 7)
   Reality: Não validado, output_digest = None se falhar

⚠️ Registry deve estar disponível (Step 3)
   Reality: Exception silenciosamente capturada

⚠️ Routing deve ser consistente (Step 1)
   Reality: Fallback para registry se router falha

⚠️ LEGACY_ACTIONS set deve ser atualizado (Steps 3B, 4A, 4B)
   Reality: Hardcoded, sem mecanismo de deprecation


================================================================================
6. SILENT FAILURE RISK CATALOG
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│ CATEGORY 1: SUPPRESSED EXCEPTIONS                                           │
└─────────────────────────────────────────────────────────────────────────────┘

RISK 1.1: Routing Failure Suppression
  Location: Step 1
  Code: except Exception: pass
  Impact: Routing error não detectado, executor_id = "unknown"
  Detection: Falha aparece em Step 4 (EXECUTOR_NOT_FOUND)
  Gap: Diferença entre "routing bug" e "executor missing" perdida

RISK 1.2: Registry Unavailable Suppression
  Location: Step 3
  Code: except Exception: pass
  Impact: Registry down não detectado, action_meta = None
  Detection: Pode falhar em Step 3A (ACTION_UNKNOWN)
  Gap: Diferença entre "registry down" e "action missing" perdida

RISK 1.3: Exception Info Loss
  Location: Step 6
  Code: except Exception as e: (e não usado)
  Impact: Stack trace e exception details perdidos
  Detection: Apenas EXECUTOR_EXCEPTION logado
  Gap: Impossível debugar executor failures


┌─────────────────────────────────────────────────────────────────────────────┐
│ CATEGORY 2: VALIDATION SKIPS                                                │
└─────────────────────────────────────────────────────────────────────────────┘

RISK 2.1: Legacy Action Bypass
  Location: Steps 3B, 4A, 4B
  Condition: action in LEGACY_ACTIONS
  Impact: AG-03 validation completamente skipped
  Detection: None
  Gap: Legacy actions podem ter incompatibilidades silenciosas

RISK 2.2: Action Meta Absence
  Location: Steps 3B, 4A, 4B
  Condition: action_meta is None
  Impact: AG-03 validation skipped se registry indisponível
  Detection: None (se action_routed=True)
  Gap: Validations só executam se metadata disponível

RISK 2.3: Empty Required Capabilities
  Location: Step 4B
  Condition: required_capabilities = []
  Impact: Capability check skipped
  Detection: None
  Gap: Executor pode não ter capabilities attribute

RISK 2.4: No Min Executor Version
  Location: Step 4A
  Condition: min_executor_version is None
  Impact: Version check skipped
  Detection: None
  Gap: Qualquer executor version aceito


┌─────────────────────────────────────────────────────────────────────────────┐
│ CATEGORY 3: INCONSISTENT STATES                                             │
└─────────────────────────────────────────────────────────────────────────────┘

RISK 3.1: Success With Invalid Output
  Location: Step 7
  State: status=SUCCESS, output_digest=None
  Cause: output não-serializável mas executor não falhou
  Impact: Cliente pensa que execução sucedeu mas output inválido
  Detection: output_digest=None mas reason_codes=[]
  Gap: Sem distinção entre "output is None" e "output invalid"

RISK 3.2: Executor Version Absence
  Location: Step 4 → Step 4A
  State: executor_version = None
  Cause: executor.version ausente ou não-string
  Impact: Se min_executor_version definido, bloqueia em 4A
  Gap: Executor pode existir mas version inválida

RISK 3.3: Payload Mutation Between Steps
  Location: Step 2 → Step 6
  State: input_digest calculado em Step 2, payload usado em Step 6
  Cause: payload é Dict mutável, passado por referência
  Impact: input_digest pode não refletir payload real executado
  Detection: None
  Gap: Audit trail pode ser inconsistente


┌─────────────────────────────────────────────────────────────────────────────┐
│ CATEGORY 4: UNENFORCED CONTRACTS                                            │
└─────────────────────────────────────────────────────────────────────────────┘

RISK 4.1: Timeout Not Enforced
  Location: Step 6
  Contract: executor.limits.timeout_ms
  Reality: Timeout nunca gerado, TimeoutError capturado mas nunca raised
  Impact: Executor pode rodar indefinidamente
  Detection: None (timeout_ms documentacional)
  Gap: DoS via slow executor

RISK 4.2: Determinism Not Verified
  Location: Step 6
  Contract: Executor protocol declara determinism
  Reality: Não verificado, replay não testado
  Impact: Executor pode usar random, timestamps, network
  Detection: None
  Gap: Audit replay pode falhar

RISK 4.3: Side-Effects Not Prevented
  Location: Step 6
  Contract: Executor protocol declara side-effect free
  Reality: Não verificado, B3-FIX mitiga com PRE-AUDIT
  Impact: Executor pode enviar webhooks, gravar DB
  Detection: PRE-AUDIT registra tentativa mas não previne
  Gap: Rollback impossível se executor viola contrato

RISK 4.4: Executor Limits Not Validated
  Location: Step 5
  Contract: executor.limits deve existir com 3 fields
  Reality: AttributeError se limits ausente (não capturado)
  Impact: Pipeline crash se executor mal-formado
  Detection: Exception não capturada
  Gap: Executor protocol não enforced


┌─────────────────────────────────────────────────────────────────────────────┐
│ CATEGORY 5: FRAGMENTATION RISKS                                             │
└─────────────────────────────────────────────────────────────────────────────┘

RISK 5.1: Router vs Registry Inconsistency
  Location: Step 1
  State: route_action_deterministic() vs action_registry.actions["executor"]
  Cause: Dois registries separados
  Impact: Routing pode divergir de metadata
  Detection: None (se ambos definidos)
  Gap: Inconsistência pode levar a executor errado

RISK 5.2: Action Metadata Fragmentation
  Location: Steps 1, 3, 3B
  State: Metadata em action_registry, router, gate_profiles
  Cause: Single source of truth não existe
  Impact: Adicionar ação requer mudar 3 arquivos
  Detection: Drift detection apenas em testes
  Gap: Inconsistência pode passar para produção


┌─────────────────────────────────────────────────────────────────────────────┐
│ CATEGORY 6: TEST POLLUTION                                                  │
└─────────────────────────────────────────────────────────────────────────────┘

RISK 6.1: MagicMock Defense
  Location: Step 4
  Code: if isinstance(exec_version_raw, str)
  Cause: Comentário "not MagicMock" indica testes influenciaram código
  Impact: Código produção tem check específico para mock objects
  Detection: Comentário explícito
  Gap: Test concerns vazaram para produção

RISK 6.2: MagicMock Defense in Capabilities
  Location: Step 4B
  Code: if not isinstance(executor_capabilities, (list, tuple, set))
  Cause: Comentário "e.g. MagicMock" indica testes influenciaram código
  Impact: Código produção tem check específico para mock objects
  Detection: Comentário explícito
  Gap: Test concerns vazaram para produção


================================================================================
7. ROUTING LOGIC DETAILED ANALYSIS
================================================================================

ROUTING SOURCES (Priority Order):

1. EXPLICIT executor_id parameter
   - Usado se fornecido e != "unknown"
   - Bypassa routing completamente
   - Comum em testes

2. route_action_deterministic()
   - Função de action_router.py
   - ACTION_REGISTRY dict: action → executor_id
   - Raises UnknownActionError se action não existe

3. action_registry.actions[action]["executor"]
   - Fallback se routing falha
   - Busca metadata da ação
   - Field "executor" pode estar ausente

INCONSISTENCIES:

Scenario A: Action em router mas não em registry
  - route_action_deterministic() retorna executor_id
  - action_routed = True
  - Step 3: action_meta = None
  - Step 3A: SKIP (porque action_routed=True)
  - Steps 3B, 4A, 4B: SKIP (porque action_meta is None)
  - Result: Execução prossegue SEM validação AG-03

Scenario B: Action em registry mas não em router
  - route_action_deterministic() raises UnknownActionError
  - Fallback: busca action_meta["executor"]
  - Se "executor" ausente: executor_id = "unknown"
  - action_routed = False
  - Step 3A: action_meta existe, continua
  - Step 4: get_executor("unknown") → EXECUTOR_NOT_FOUND
  - Result: BLOCKED tarde (em Step 4, não em routing)

Scenario C: Routing diverge de metadata
  - Router: "action_x" → "executor_v1"
  - Registry: action_x.executor = "executor_v2"
  - Routing retorna "executor_v1"
  - Step 3: action_meta tem min_executor_version para "executor_v2"
  - Step 4: Resolve "executor_v1"
  - Step 4A: Compara "executor_v1".version com min para "executor_v2"
  - Result: Version check usa metadata errada (mismatch entre executor e metadata)

ROUTING FLOW DIAGRAM:

START: executor_id parameter
  │
  ├─ IF executor_id != "unknown"
  │    └─ USE: explicit executor_id (bypass routing)
  │
  └─ ELSE:
       ├─ TRY: route_action_deterministic(action)
       │    ├─ SUCCESS: executor_id = resultado
       │    │           action_routed = True
       │    └─ EXCEPT:
       │         └─ TRY: action_registry.actions[action]["executor"]
       │              ├─ SUCCESS: executor_id = resultado
       │              │           action_routed = True if != "unknown"
       │              └─ EXCEPT:
       │                   └─ executor_id = "unknown"
       │                      action_routed = False


================================================================================
8. FAILURE MODE MATRIX
================================================================================

STEP  | FAILURE MODE                        | REASON CODE                   | LOGGED
------|-------------------------------------|-------------------------------|--------
1     | Routing exception                   | (none, silent)                | No
1     | Registry exception                  | (none, silent)                | No
2     | Payload non-serializable            | NON_JSON_PAYLOAD              | Yes
3     | Registry exception                  | (none, silent)                | No
3A    | Action unknown                      | ACTION_UNKNOWN                | Yes
3B    | action_version missing              | ACTION_VERSION_MISSING        | Yes
3B    | action_version invalid semver       | ACTION_VERSION_INVALID        | Yes
4     | Executor not found                  | EXECUTOR_NOT_FOUND            | Yes
4A    | executor_version missing            | EXECUTOR_VERSION_MISSING      | Yes
4A    | executor_version incompatible       | EXECUTOR_VERSION_INCOMPATIBLE | Yes
4A    | Version comparison error            | EXECUTOR_VERSION_INCOMPATIBLE | Yes
4B    | Capabilities missing                | EXECUTOR_CAPABILITY_MISSING   | Yes
4B    | Capabilities mismatch               | EXECUTOR_CAPABILITY_MISMATCH  | Yes
5     | Payload non-serializable (again)    | NON_JSON_PAYLOAD              | Yes
5     | Payload exceeds limits              | LIMIT_EXCEEDED                | Yes
6a    | (PRE-AUDIT always succeeds)         | -                             | Yes
6b    | Timeout (never actually raised)     | EXECUTOR_TIMEOUT              | Yes
6b    | Executor exception                  | EXECUTOR_EXCEPTION            | Yes
7     | Output non-serializable             | (none, output_digest=None)    | No

OBSERVATIONS:
  - 3 failure modes são silent (não logados, não bloqueiam)
  - 1 failure mode é inconsistent (output_digest=None mas SUCCESS)
  - 1 failure mode nunca acontece (EXECUTOR_TIMEOUT)
  - Total de 18 failure modes, 15 geram reason_codes


================================================================================
9. PAYLOAD JOURNEY THROUGH PIPELINE
================================================================================

PAYLOAD STATE AT EACH STEP:

Step 0 (Entry):
  - payload: Dict[str, Any] (from HTTP or caller)
  - Passed by reference (mutável)

Step 1 (Routing):
  - payload: not accessed
  - State: unchanged

Step 2 (Input Digest):
  - payload: serializado para JSON canônico
  - input_digest = SHA256(json.dumps(payload))
  - State: read-only, mas mutável

Step 3-4B (Validations):
  - payload: not accessed
  - State: pode mutar se caller modifica (risk)

Step 5 (Limits):
  - payload: serializado novamente (canonical_json_bytes)
  - payload: traversed (max_depth, max_list_items)
  - State: read-only, mas mutável

Step 6a (PRE-AUDIT):
  - payload: not accessed
  - State: pode mutar antes de Step 6b

Step 6b (Execution):
  - payload: passado para ActionRequest(payload=payload)
  - ActionRequest é frozen (payload fica imutável?)
  - Executor recebe ActionRequest
  - Executor pode acessar req.payload
  - State: executor pode mutar payload (não verificado)

Step 7 (POST-AUDIT):
  - payload: not accessed
  - State: payload original pode ter mutado

MUTATION RISK:

Timeline:
  t0: payload enter pipeline
  t1: input_digest = SHA256(payload) [snapshot]
  t2: ...validações...
  t3: ActionRequest created with payload [reference]
  t4: executor.execute(ActionRequest) [executor acessa payload]
  t5: executor returns
  t6: ActionResult logged

Risk:
  - Se payload mutar entre t1 e t4, input_digest não reflete payload real
  - Se executor mutar payload, audit trail inconsistent
  - ActionRequest é frozen mas payload field é Dict (mutável)

MITIGATION:
  - ActionRequest.model_config = frozen=True
  - Mas Dict fields são shallow frozen (conteúdo mutável)


================================================================================
10. TRACE_ID PROPAGATION ANALYSIS
================================================================================

TRACE_ID LIFECYCLE:

Origin: main.py (gate_request dependency)
  trace_id = str(uuid.uuid4())

Propagation Path:
  1. DecisionRecord (gate audit)
     - trace_id field
  2. ActionRequest (pipeline input)
     - trace_id field
  3. ActionResult (PRE-AUDIT)
     - trace_id field
  4. ActionResult (POST-AUDIT)
     - trace_id field
  5. HTTP response
     - trace_id field

Executor Access:
  - Executor recebe ActionRequest
  - ActionRequest.trace_id é acessível
  - Executor PODE usar trace_id (não requerido)

ASSUMPTIONS:
  - trace_id é único (UUID collision risk negligível)
  - trace_id não muda durante execução
  - trace_id correlaciona gate + pipeline + HTTP

MISSING:
  - Sem span_id (distributed tracing)
  - Sem parent_trace_id (composition)
  - Sem tenant_id (multi-tenant)
  - Sem user_id (user tracking)
  - Sem session_id (session tracking)


================================================================================
END OF STAGE 2
================================================================================

SUMMARY OF PIPELINE ANALYSIS:

EXECUTION MODEL:
  - 8 steps linear: Routing → Digest → Registry → Validation → Limits → PRE-AUDIT → Execute → POST-AUDIT
  - Fail-fast: primeiro erro bloqueia
  - Stateless: sem side-effects declarado
  - Synchronous: sem async, sem timeout enforcement

CRITICAL FINDINGS:

STRENGTHS:
  - PRE-AUDIT garante auditabilidade (B3-FIX)
  - Fail-closed enforcement em validações AG-03
  - Privacy by design (output nunca retornado)
  - Comprehensive validation chain

WEAKNESSES:
  - 3 silent failures (routing, registry, output digest)
  - Timeout não enforced (EXECUTOR_TIMEOUT nunca gerado)
  - Payload mutation risk (digest vs execution)
  - Test pollution (MagicMock defense no código)
  - Registry fragmentation (router vs action_registry)
  - Legacy action bypass (AG-03 validation skipped)

IMPLICIT ASSUMPTIONS:
  - Executor determinism (not enforced)
  - Executor side-effect free (not enforced, PRE-AUDIT mitiga)
  - Timeout gerado por executor (not true)
  - Registry always available (exceptions suppressed)
  - Output is valid (not validated)

SILENT FAILURE RISKS:
  - 18 failure modes identificados
  - 3 são completamente silent
  - 1 é inconsistent (SUCCESS com output_digest=None)
  - Exception details perdidos (sem stack trace)
  - Routing errors suprimidos

PRÓXIMO STAGE: Stage 3 — Governance Integrity Analysis
