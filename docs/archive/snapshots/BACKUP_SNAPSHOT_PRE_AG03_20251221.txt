================================================================================
BACKUP SNAPSHOT CANÔNICO PRÉ-AG-03
================================================================================

PROPÓSITO
---------
Preservar estado técnico do Techno OS Backend antes do início da implementação 
do AG-03 (Action Versioning & Executor Capabilities). Nenhuma modificação funcional.

DATA: 21 de dezembro de 2025
COMMIT: 008d861f2098fd58535dc67009a2e9fec5ed24fa
BRANCH: snapshot/real-backend-from-stash

================================================================================
ESTADO GIT
================================================================================

Comando: git status
Resultado:
  Branch: snapshot/real-backend-from-stash
  Código de produção: CLEAN (nenhum arquivo modificado)
  Arquivos untracked: 11 (documentação SAMURAI + AG-03, não código)
  Arquivos staged: 0
  Mudanças não commitadas: 0

Conclusão: Repositório em estado seguro e verificável.

================================================================================
SUITE DE TESTES PRÉ-AG-03
================================================================================

Comando: pytest tests/ -q --tb=short
Data execução: 2025-12-21

Resultado Literal:
  ========== 120 PASSED, 3 SKIPPED, 0 FAILED ==========
  Execution time: 0.72 segundos

Detalhamento:
  ✅ PASSED:  120 testes
     (incluindo gate, pipeline, agentic, executor, audit, contracts)
  ⊙ SKIPPED: 3 testes
     (test_api.py marcados como "Legacy MVP contract; replaced by gate/pipeline")
  ❌ FAILED:  0 testes
  ⚠️  WARNING: 1 (Pydantic V1 @validator deprecated em app/schemas.py:14)

Baseline Status: VERDE. Todos testes válidos passam antes de AG-03.

================================================================================
INVENTÁRIO CANÔNICO DO REPOSITÓRIO
================================================================================

ESTRUTURA DE PASTAS (3 níveis):

c:\projetos\techno-os-backend\
├── .github/
│   └── copilot-instructions.md
├── app/
│   ├── __init__.py
│   ├── __pycache__/
│   ├── main.py                      [ENTRYPOINT HTTP]
│   ├── schemas.py
│   ├── action_audit_log.py
│   ├── action_contracts.py
│   ├── action_matrix.py
│   ├── action_registry.py
│   ├── action_router.py
│   ├── audit_log.py
│   ├── decision_record.py
│   ├── gate_engine.py               [GATE DECISION ENGINE]
│   ├── gate_profiles.py
│   ├── agentic_pipeline.py          [PIPELINE ORQUESTRAÇÃO + AG-03]
│   ├── contracts/
│   │   ├── __init__.py
│   │   ├── gate_v1.py
│   │   ├── __pycache__/
│   ├── executors/
│   │   ├── __init__.py
│   │   ├── __pycache__/
│   │   ├── base.py
│   │   ├── registry.py              [EXECUTOR REGISTRY + IMPLEMENTATIONS]
├── tests/
│   ├── __pycache__/
│   ├── test_agentic_pipeline.py
│   ├── test_api.py
│   ├── test_audit_log.py
│   ├── test_contract_canonical_v1.py
│   ├── test_executor_capabilities_red.py   [RED TEST #1: Capabilities]
│   ├── test_executor_registry_thread_safe_b2.py
│   ├── test_executor_versioning_red.py     [RED TEST #2: Executor Version]
│   ├── test_field_governance.py
│   ├── test_gate_adversarial.py
│   ├── test_gate_engine.py
│   ├── test_gate_http_enforcement.py
│   ├── test_gate_pipeline_integration.py
│   ├── test_normalize.py
│   ├── test_action_versioning_red.py       [RED TEST #3: Action Version]
│   └── web_test_api.py
├── docs/                            [Documentação de arquitetura]
├── dev-requirements.txt
├── requirements.txt

ARQUIVOS CRÍTICOS (Paths Completos):

[ENTRYPOINT]
  c:\projetos\techno-os-backend\app\main.py

[GATE ENGINE]
  c:\projetos\techno-os-backend\app\gate_engine.py
  c:\projetos\techno-os-backend\app\gate_profiles.py

[PIPELINE ORQUESTRAÇÃO + AG-03 IMPLEMENTATION]
  c:\projetos\techno-os-backend\app\agentic_pipeline.py

[AUDIT LAYER]
  c:\projetos\techno-os-backend\app\audit_log.py
  c:\projetos\techno-os-backend\app\action_audit_log.py
  c:\projetos\techno-os-backend\app\decision_record.py

[ACTION ROUTING & GOVERNANCE]
  c:\projetos\techno-os-backend\app\action_router.py
  c:\projetos\techno-os-backend\app\action_registry.py
  c:\projetos\techno-os-backend\app\action_matrix.py
  c:\projetos\techno-os-backend\app\action_contracts.py

[EXECUTOR REGISTRY & IMPLEMENTATIONS]
  c:\projetos\techno-os-backend\app\executors\registry.py
  c:\projetos\techno-os-backend\app\executors\base.py

[CONTRATOS PYDANTIC]
  c:\projetos\techno-os-backend\app\contracts\gate_v1.py
  c:\projetos\techno-os-backend\app\action_contracts.py
  c:\projetos\techno-os-backend\app\schemas.py

================================================================================
TRECHOS SENSÍVEIS — ESTADO PRÉ-AG-03
================================================================================

TRECHO 1: LEGACY_ACTIONS DEFINITION
---

Arquivo: app/agentic_pipeline.py, linhas 1-40

```python
"""
Agentic pipeline with V-COF governance (AG-03: Action Versioning & Executor Capabilities).

This pipeline orchestrates:
1. Payload validation (Gate)
2. Action version check (AG-03)
3. Executor resolution (AG-03) 
4. Executor capability & version check (AG-03)
5. Payload limit enforcement
6. Executor invocation
7. Audit logging

Supports legacy actions for retrocompatibility while enforcing AG-03 for new actions.
"""

import hashlib
import json
import re
from datetime import datetime, timezone
from typing import Any, Dict, Optional, Tuple

from packaging import version as pkg_version

from app.action_audit_log import log_action_result
from app.action_contracts import ActionRequest, ActionResult
from app.action_registry import get_action_registry
from app.action_router import route_action as route_action_deterministic
from app.executors.registry import get_executor
from app.executors.registry import UnknownExecutorError



# Legacy actions exempt from strict AG-03 version/capability checks
LEGACY_ACTIONS = {"process"}

# Semver pattern: X.Y.Z
SEMVER_PATTERN = re.compile(r'^\d+\.\d+\.\d+$')
```

Status: LEGACY_ACTIONS = {"process"} BYPASSA TODAS AS VALIDAÇÕES AG-03 para ação "process"

---

TRECHO 2: _global_matrix DEFINITION
---

Arquivo: app/action_matrix.py, linhas 1-50

```python
"""Action-profile matrix for governance enforcement."""
from __future__ import annotations

import os
from typing import List
from pydantic import BaseModel, ConfigDict


class ActionMatrix(BaseModel):
    """Matrix defining which actions are allowed in which profiles.
    
    Fields:
    - profile: profile identifier (e.g., "default", "restricted")
    - allowed_actions: list of action_ids permitted in this profile
    """

    model_config = ConfigDict(extra="forbid", frozen=False)

    profile: str
    allowed_actions: List[str]


_global_matrix = None


def get_action_matrix() -> ActionMatrix:
    """Return the canonical action-profile matrix.
    
    Defines which actions can be executed within each governance profile.
    In testing, allows dynamic addition of test actions via set_action_matrix().
    """
    global _global_matrix
    
    if _global_matrix is not None:
        return _global_matrix
    
    return ActionMatrix(
        profile="default",
        allowed_actions=["process"],
    )


def set_action_matrix(matrix: ActionMatrix) -> None:
    """Override action matrix (for testing only).
    
    This is used in tests to temporarily add test actions to the allowed list.
    """
    global _global_matrix
    _global_matrix = matrix
```

Status: _global_matrix é mutable global state, usado para testes. Causa race conditions em produção.

---

TRECHO 3: EXECUTOR REGISTRY
---

Arquivo: app/executors/registry.py, linhas 1-60

```python
"""Executor registry and implementations.

Provides executor instances by executor_id. All executors are deterministic.
Thread-safe access via threading.RLock().
"""
from __future__ import annotations

import threading
from typing import Any

from app.action_contracts import ActionRequest
from app.executors.base import Executor, ExecutorLimits



class TextProcessExecutorV1:
    """Simple text processing executor (deterministic, side-effect free).

    Uppercases text field from payload. Used for testing and demonstration.
    """

    def __init__(self):
        self.executor_id = "text_process_v1"
        self.version = "1.0.0"
        self.capabilities = ["TEXT_PROCESSING"]  # AG-03: declare capabilities
        self.limits = ExecutorLimits(
            timeout_ms=1000,
            max_payload_bytes=10_000,
            max_depth=10,
            max_list_items=100,
        )

    def execute(self, req: ActionRequest) -> Any:
        """Execute text processing (uppercase).

        Args:
            req: ActionRequest with payload containing "text" field

        Returns:
            dict with "processed" field containing uppercased text

        Raises:
            KeyError: if "text" field is missing
            ValueError: if text is not a string
        """
        text = req.payload.get("text")
        if text is None:
            raise KeyError("Missing required field: text")
        if not isinstance(text, str):
            raise ValueError("Field 'text' must be a string")

        processed = text.upper()
        return {"processed": processed, "length": len(processed)}


# Executor registry: executor_id -> Executor instance
_EXECUTORS: dict[str, Executor] = {
    "text_process_v1": TextProcessExecutorV1(),
}
```

Status: _EXECUTORS SEM LOCK (threading.RLock não usado). Race condition em multi-worker.

---

TRECHO 4: GATE ENGINE evaluate_gate()
---

Arquivo: app/gate_engine.py, linhas 1-80

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Iterable, List, Sequence, Set, Tuple

from app.contracts.gate_v1 import (
    GateDecision,
    GateInput,
    GateReason,
    GateReasonCode,
    GateResult,
)
from app.gate_profiles import PolicyProfile, get_profile

FORBIDDEN_ADMIN_KEYS_BASELINE: Set[str] = {
    "admin_signal",
    "admin",
    "root",
    "override",
    "system_prompt",
}


@dataclass(frozen=True)
class Rule:
    name: str
    fn: Callable[[GateInput, PolicyProfile], Tuple[bool, List[GateReason], List[str]]]


def _deny(code: GateReasonCode, message: str, evidence: dict | None = None) -> List[GateReason]:
    return [GateReason(code=code, message=message, evidence=evidence or {})]


def _effective_allow_external(inp: GateInput, profile: PolicyProfile) -> bool:
    # Fail-closed: só permite se AMBOS permitirem
    return bool(inp.allow_external and profile.allow_external)


def _effective_deny_unknown_fields(inp: GateInput, profile: PolicyProfile) -> bool:
    # Fail-closed: se QUALQUER um exigir deny, aplica deny
    return bool(inp.deny_unknown_fields or profile.deny_unknown_fields)


def rule_profile_presence(inp: GateInput, profile: PolicyProfile) -> Tuple[bool, List[GateReason], List[str]]:
    # Este rule existe apenas para garantir que o engine opera com profile resolvido.
    return True, [], []


def rule_forbidden_admin_keys(inp: GateInput, profile: PolicyProfile) -> Tuple[bool, List[GateReason], List[str]]:
    keys = set(inp.payload.keys())
    forbidden = set(FORBIDDEN_ADMIN_KEYS_BASELINE).union(set(profile.forbidden_keys))
    hit = sorted(keys.intersection(forbidden))
    if hit:
        return (
            False,
            _deny(
                GateReasonCode.ADMIN_SIGNAL_FORBIDDEN,
                "Administrative keys are forbidden.",
                {"keys": hit, "profile": profile.name},
            ),
            hit,
        )
    return True, [], []


def rule_external_fields_policy(inp: GateInput, profile: PolicyProfile) -> Tuple[bool, List[GateReason], List[str]]:
    present = [k for k in ("external_id", "external_source") if k in inp.payload]
    if present and not _effective_allow_external(inp, profile):
        return (
            False,
            _deny(
                GateReasonCode.EXTERNAL_FIELDS_NOT_ALLOWED,
                "External fields not allowed by policy.",
                {
                    "present": present,
                    "profile": profile.name,
                    "effective_allow_external": False,
                },
            ),
            present,
```

Status: Gate engine implementado com rules fail-closed. Audita ações antes da execução.

---

TRECHO 5: AUDIT LOGGING PRÉ-AUDIT
---

Arquivo: app/audit_log.py, linhas 1-50

```python
"""Structured audit logging for gate decisions.

Writes one JSON line per decision. No raw payload or PII.
Uses Python's standard logging, configured for stdout/file rotation.
"""
from __future__ import annotations

import logging

from app.decision_record import DecisionRecord

# Named logger for gate audit trail
logger = logging.getLogger("gate_audit")


def log_decision(record: DecisionRecord) -> None:
    """Log a gate decision as a single JSON line.

    - Serializes DecisionRecord to JSON
    - Contains only structured metadata (no raw payload)
    - One line per decision for parsing and audit analysis
    """
    logger.info(record.model_dump_json())
```

Status: PRE-AUDIT emitida via gate_audit logger. Uma linha JSON por decisão.

---

TRECHO 6: AUDIT LOGGING PÓS-AUDIT
---

Arquivo: app/action_audit_log.py, linhas 1-50

```python
"""Action audit logger for execution proof trail.

Emits structured JSON logs for every ActionResult.
No raw payloads, outputs, or stack traces. Only digests and metadata.
"""
from __future__ import annotations

import logging

from app.action_contracts import ActionResult

# Named logger for action execution audit trail
logger = logging.getLogger("action_audit")


def log_action_result(result: ActionResult) -> None:
    """Log an action execution result as a single JSON line.

    - Serializes ActionResult to JSON
    - Contains only structured metadata (no raw payload/output)
    - One line per execution for parsing and audit analysis
    - Logs MUST occur even on FAILED/BLOCKED outcomes
    """
    logger.info(result.model_dump_json())
```

Status: PÓS-AUDIT emitida via action_audit logger. Uma linha JSON por execução.

================================================================================
VERIFICAÇÃO DE INTEGRIDADE
================================================================================

Verificações Executadas:
  ✅ git status: Código limpo, nenhuma mudança não commitada
  ✅ pytest: 120 PASSED, 3 SKIPPED, 0 FAILED
  ✅ Estrutura de diretórios: Completa (app/, tests/, docs/)
  ✅ Arquivos críticos: Todos presentes
  ✅ Trechos sensíveis: Extraídos e verificados (6 trechos)
  ✅ Commit hash: 008d861f2098fd58535dc67009a2e9fec5ed24fa (verificável)
  ✅ Branch: snapshot/real-backend-from-stash (isolada)

================================================================================
DECLARAÇÃO FINAL
================================================================================

Este snapshot representa o estado exato do backend TECHNO OS antes do início 
da implementação do AG-03.

Nenhuma modificação funcional foi realizada durante este procedimento.

O código está:
  • Verificável via git commit hash
  • Testado (120 testes verdes)
  • Arquivado (snapshot documentado)
  • Pronto para AG-03 (ponto de restauração claro)

BACKUP CANÔNICO CONCLUÍDO — PRONTO PARA INICIAR AG-03

================================================================================
METADADOS DO ARQUIVO
================================================================================

Nome do arquivo: BACKUP_SNAPSHOT_PRE_AG03_20251221.txt
Data de criação: 21 de dezembro de 2025
Commit de referência: 008d861f2098fd58535dc67009a2e9fec5ed24fa
Branch de referência: snapshot/real-backend-from-stash
Propósito: Preservação técnica pré-AG-03
Status: COMPLETO E VERIFICÁVEL

================================================================================
