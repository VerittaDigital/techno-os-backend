# EXECUTION SEMANTICS V1 — NOTION ⇄ BACKEND

Techno OS Control-Plane Governance
Document Version: 1.1
Date: 2025-12-31

================================================================================

1. REGRAS DE ORIGEM POR EVENTO

1.1 Event Types criados pelo Notion (Event Source=notion)

1.1.1 Event Type: request_created
	Origin: Notion database quando usuario cria nova linha de execucao
	Payload: action, input_summary, requester_id
	Semantica: Usuario declarou intencao de executar acao
	Restricao: Nao representa autorizacao nem execucao real

1.1.2 Event Type: authorization_requested
	Origin: Notion quando usuario move status para "pending_auth"
	Payload: request_id, action, requester_id
	Semantica: Usuario solicitou autorizacao para gate
	Restricao: Nao garante que gate sera consultado

1.1.3 Event Type: execution_requested
	Origin: Notion quando usuario move status para "pending_exec"
	Payload: request_id, action, payload_digest
	Semantica: Usuario solicitou execucao no backend
	Restricao: Nao garante que executor sera invocado

1.1.4 Event Type: user_annotation
	Origin: Notion quando usuario adiciona nota ou comentario
	Payload: request_id, annotation_text, user_id
	Semantica: Usuario registrou observacao humana
	Restricao: Nao afeta fluxo de execucao

1.2 Event Types exclusivos do backend (Event Source=backend)

1.2.1 Event Type: authorized
	Origin: Backend apos evaluate_gate retornar ALLOW
	Payload: request_id, trace_id, decision=ALLOW, profile_hash, matched_rules
	Semantica: Gate autorizou execucao
	Restricao: Unico evento que representa autorizacao real

1.2.2 Event Type: denied
	Origin: Backend apos evaluate_gate retornar DENY
	Payload: request_id, trace_id, decision=DENY, reason_codes
	Semantica: Gate negou execucao
	Restricao: Terminal para este request_id (nao pode virar authorized sem nova avaliacao)

1.2.3 Event Type: executed
	Origin: Backend apos run_agentic_action retornar SUCCESS
	Payload: request_id, trace_id, status=SUCCESS, executor_id, executor_version, output_digest
	Semantica: Executor completou execucao com sucesso
	Restricao: Deve sempre ter authorized correspondente com mesmo trace_id

1.2.4 Event Type: execution_failed
	Origin: Backend apos run_agentic_action retornar FAILED
	Payload: request_id, trace_id, status=FAILED, reason_codes, executor_id
	Semantica: Executor falhou durante execucao
	Restricao: Deve sempre ter authorized correspondente com mesmo trace_id

1.2.5 Event Type: execution_blocked
	Origin: Backend apos run_agentic_action retornar BLOCKED
	Payload: request_id, trace_id, status=BLOCKED, reason_codes
	Semantica: Execucao bloqueada por governanca (audit fail, timeout, etc)
	Restricao: Pode ocorrer mesmo com authorized previo

1.2.6 Event Type: execution_timeout
	Origin: Backend quando FuturesTimeoutError capturado
	Payload: request_id, trace_id, status=BLOCKED, reason_codes=[EXECUTOR_TIMEOUT]
	Semantica: Executor excedeu timeout configurado
	Restricao: Subtipo de execution_blocked

1.2.7 Event Type: auth_failure
	Origin: Backend quando X-API-Key invalida ou ausente
	Payload: request_id, trace_id, decision=DENY, reason_codes=[AUTH_MISSING_KEY ou AUTH_INVALID_KEY]
	Semantica: Request rejeitado antes de gate por falha de autenticacao
	Restricao: Terminal para este request_id (nao pode prosseguir sem credencial valida)

1.3 Regra de unicidade de origem

1.3.1 Event Type com Event Source=notion NAO PODE ser criado pelo backend
	Violacao: Backend criar request_created ou authorization_requested
	Consequencia: Inconsistencia detectavel via Event Source field

1.3.2 Event Type com Event Source=backend NAO PODE ser criado pelo Notion
	Violacao: Notion criar authorized ou executed manualmente
	Consequencia: Evidence sem audit trail correspondente (orfao)

1.3.3 Notion pode criar eventos de intencao mas nunca eventos de confirmacao
	Principio: Notion declara o que usuario quer, backend confirma o que aconteceu

================================================================================

2. REGRAS DE COMPLETUDE DO CICLO

2.1 Ciclos validos completos

2.1.1 Ciclo autorizado e executado com sucesso
	request_created (notion) → authorization_requested (notion) → authorized (backend) → execution_requested (notion) → executed (backend)
	Caracteristica: trace_id presente em authorized e executed (mesmo valor)
	Estado final: request_id tem 1 authorized + 1 executed

2.1.2 Ciclo autorizado mas execucao falhou
	request_created (notion) → authorization_requested (notion) → authorized (backend) → execution_requested (notion) → execution_failed (backend)
	Caracteristica: trace_id presente em authorized e execution_failed (mesmo valor)
	Estado final: request_id tem 1 authorized + 1 execution_failed

2.1.3 Ciclo autorizado mas execucao bloqueada
	request_created (notion) → authorization_requested (notion) → authorized (backend) → execution_requested (notion) → execution_blocked (backend)
	Caracteristica: trace_id presente em authorized e execution_blocked (mesmo valor)
	Estado final: request_id tem 1 authorized + 1 execution_blocked

2.1.4 Ciclo negado no gate
	request_created (notion) → authorization_requested (notion) → denied (backend)
	Caracteristica: trace_id presente apenas em denied (nao ha execucao)
	Estado final: request_id tem 1 denied, sem executed/execution_failed/execution_blocked

2.1.5 Ciclo rejeitado por auth
	request_created (notion) → authorization_requested (notion) → auth_failure (backend)
	Caracteristica: trace_id presente em auth_failure
	Estado final: request_id tem 1 auth_failure, sem authorized nem executed

2.2 Quando authorized pode existir sem executed/execution_failed/execution_blocked

2.2.1 Caso valido A: Usuario ainda nao solicitou execucao
	Estado: request_id tem authorized mas nenhum execution_requested
	Semantica: Gate autorizou mas usuario nao prosseguiu
	Acao: Nenhuma inconsistencia, estado transitorio normal

2.2.2 Caso valido B: Usuario solicitou execucao mas backend ainda processando
	Estado: request_id tem authorized + execution_requested mas nenhum executed/execution_failed/execution_blocked
	Semantica: Request em andamento (PENDING)
	Acao: Nenhuma inconsistencia se tempo decorrido < timeout esperado

2.2.3 Caso valido C: Backend perdeu conexao ou crashou durante execucao
	Estado: request_id tem authorized + execution_requested mas nenhum executed/execution_failed/execution_blocked apos timeout
	Semantica: Execucao real ocorreu ou nao, mas backend nao confirmou
	Acao: Inconsistencia operacional (nao semantica), requer investigacao de logs

2.2.4 Caso invalido: authorized sem trace_id
	Estado: Event authorized existe mas campo trace_id ausente ou vazio
	Semantica: Evidence malformada
	Acao: Inconsistencia estrutural, evento deve ser descartado

2.3 O que constitui inconsistencia real

2.3.1 Inconsistencia I1: executed sem authorized previo
	Deteccao: request_id tem executed mas nenhum authorized com mesmo trace_id
	Causa provavel: Evidence criado manualmente no Notion ou trace_id incorreto
	Severidade: CRITICA (violacao de governanca)
	Regra: executed SEMPRE exige authorized com trace_id identico

2.3.2 Inconsistencia I2: execution_failed sem authorized previo
	Deteccao: request_id tem execution_failed mas nenhum authorized com mesmo trace_id
	Causa provavel: Evidence criado manualmente ou trace_id incorreto
	Severidade: CRITICA (violacao de governanca)
	Regra: execution_failed SEMPRE exige authorized com trace_id identico

2.3.3 Inconsistencia I3: execution_blocked sem authorized previo
	Deteccao: request_id tem execution_blocked mas nenhum authorized com mesmo trace_id
	Causa provavel: Audit failure impediu gravacao de authorized
	Severidade: MEDIA (pode ser fail-closed legitimo se reason_codes=[AUDIT_LOG_FAILED])
	Regra: execution_blocked PODE existir sem authorized apenas se reason_codes indica falha de audit

2.3.4 Inconsistencia I4: Multiplos authorized para mesmo request_id
	Deteccao: request_id tem 2+ eventos authorized com trace_id diferentes
	Causa provavel: Usuario solicitou autorizacao multiplas vezes
	Severidade: BAIXA (valido se payload ou contexto mudou)
	Regra: Multiplos authorized sao validos mas apenas o mais recente por ts_utc deve ser considerado ativo

2.3.5 Inconsistencia I5: Multiplos executed para mesmo trace_id
	Deteccao: trace_id tem 2+ eventos executed
	Causa provavel: Retry acidental ou duplicacao de evento
	Severidade: CRITICA (violacao de idempotencia)
	Regra: Para mesmo trace_id, apenas 1 evento de conclusao (executed/execution_failed/execution_blocked) pode existir

2.3.6 Inconsistencia I6: executed com Event Source=notion
	Deteccao: Event executed tem Event Source diferente de backend
	Causa provavel: Usuario criou executed manualmente no Notion
	Severidade: CRITICA (falsificacao de execucao)
	Regra: executed NUNCA pode ter Event Source=notion

2.3.7 Inconsistencia I7: authorized e denied simultaneos para mesmo request_id
	Deteccao: request_id tem authorized e denied (qualquer trace_id)
	Causa provavel: Usuario solicitou autorizacao multiplas vezes com payloads diferentes
	Severidade: BAIXA (valido se timestamps diferentes)
	Regra: Evento mais recente por ts_utc prevalece

================================================================================

3. REGRAS PARA EVIDENCE

3.1 Quando uma Evidence e considerada valida

3.1.1 Evidence valida tipo authorized:
	Campo Event Type = authorized
	Campo Event Source = backend
	Campo trace_id presente e nao vazio
	Campo profile_hash presente e match sha256 pattern
	Campo matched_rules e list (pode ser vazia)
	Campo decision = ALLOW
	Nenhum campo obrigatorio ausente

3.1.2 Evidence valida tipo denied:
	Campo Event Type = denied
	Campo Event Source = backend
	Campo trace_id presente e nao vazio
	Campo reason_codes presente e nao vazio (list)
	Campo decision = DENY
	Nenhum campo obrigatorio ausente

3.1.3 Evidence valida tipo executed:
	Campo Event Type = executed
	Campo Event Source = backend
	Campo trace_id presente e nao vazio
	Campo executor_id presente e nao vazio
	Campo executor_version presente e nao vazio
	Campo status = SUCCESS
	Campo output_digest presente (pode ser null se output nao JSON-serializable)
	Existe Evidence authorized com mesmo trace_id

3.1.4 Evidence valida tipo execution_failed:
	Campo Event Type = execution_failed
	Campo Event Source = backend
	Campo trace_id presente e nao vazio
	Campo status = FAILED
	Campo reason_codes presente e nao vazio (list)
	Existe Evidence authorized com mesmo trace_id

3.1.5 Evidence valida tipo execution_blocked:
	Campo Event Type = execution_blocked
	Campo Event Source = backend
	Campo trace_id presente e nao vazio
	Campo status = BLOCKED
	Campo reason_codes presente e nao vazio (list)
	Pode ou nao ter authorized previo (dependendo de reason_codes)

3.2 Como tratar evidencia orfa

3.2.1 Evidencia orfa tipo A: executed sem authorized correspondente
	Definicao: Evidence executed tem trace_id mas nenhum authorized com esse trace_id
	Tratamento: Marcar Evidence como INVALID
	Acao: Buscar audit trail no backend (VERITTA_AUDIT_LOG_PATH) para confirmar se executed e legitimo
	Se audit trail confirma: Evidence authorized foi perdido (nao criado no Notion), criar manualmente com dados do audit
	Se audit trail nao confirma: Evidence executed e falso, deletar do Notion

3.2.2 Evidencia orfa tipo B: authorized sem audit trail correspondente
	Definicao: Evidence authorized existe no Notion mas trace_id nao encontrado em audit.log
	Tratamento: Marcar Evidence como SUSPECT
	Acao: Verificar timestamp do Evidence vs timestamp do audit.log mais recente
	Se timestamp Evidence > timestamp audit.log: Backend pode nao ter sincronizado ainda (aguardar)
	Se timestamp Evidence << timestamp audit.log: Evidence e falso, deletar do Notion

3.2.3 Evidencia orfa tipo C: execution_requested sem executed/execution_failed/execution_blocked
	Definicao: Evidence execution_requested existe mas nenhum evento de conclusao
	Tratamento: Marcar request_id como PENDING se tempo decorrido < 60 segundos
	Acao: Se tempo decorrido > 60 segundos, buscar audit trail para confirmar status real
	Se audit trail confirma conclusao: Evidence de conclusao nao foi criado no Notion, criar manualmente
	Se audit trail nao confirma conclusao: Request travado ou backend crashou, marcar como UNKNOWN

3.3 Como tratar audit orfao

3.3.1 Audit orfao: Entrada em audit.log sem Evidence correspondente no Notion
	Definicao: trace_id encontrado em audit.log mas nenhum Evidence no Notion com esse trace_id
	Tratamento: Criar Evidence no Notion a partir dos dados do audit.log
	Campos a extrair:
	  - trace_id
	  - decision (ALLOW/DENY)
	  - status (SUCCESS/FAILED/BLOCKED)
	  - reason_codes
	  - profile_hash
	  - matched_rules
	  - executor_id
	  - executor_version
	  - input_digest
	  - output_digest
	  - ts_utc
	Event Source: backend
	Event Type: Derivar de decision e status (authorized, denied, executed, execution_failed, execution_blocked)

3.3.2 Auditoria sem request_id vinculado:
	Definicao: audit.log tem trace_id mas nenhum request_id conhecido no Notion
	Tratamento: Criar novo request_id no Notion
	Semantica: Execucao ocorreu via API direta (nao via Notion UI)
	Acao: Criar Evidence e vincular a request_id sintetico gerado

================================================================================

4. REGRA MESTRA

4.1 Principio de nao-repudio da execucao

4.1.1 Nenhum estado no Notion representa execucao real sem confirmacao do backend
	Implicacao: Campo status no Notion (ex: "executed", "failed") e apenas UI hint
	Verdade: Status real esta em Event Type do Evidence mais recente com Event Source=backend
	Corolario: Usuario pode mudar status no Notion mas isso nao muda realidade da execucao

4.1.2 Evidence com Event Source=backend e imutavel
	Regra: Evidence criado pelo backend NAO PODE ser editado manualmente no Notion
	Violacao: Edicao manual de Evidence backend invalida toda cadeia de governanca
	Deteccao: Comparar hash dos campos obrigatorios com audit.log correspondente

4.1.3 trace_id e autoridade canonica de correlacao
	Regra: Mesmo request_id pode ter multiplos trace_id se usuario reautorizar
	Regra: Mesmo trace_id NUNCA pode ter multiplos eventos de conclusao
	Regra: Para determinar estado atual do request_id, usar Evidence mais recente por ts_utc

4.1.4 Audit trail e fonte de verdade para disputas
	Regra: Se Evidence no Notion contradiz audit.log, audit.log prevalece
	Regra: Se audit.log ausente para trace_id, Evidence e invalido ate prova em contrario
	Regra: audit.log e append-only, Evidence no Notion pode ser deletado/recriado

4.2 Propriedade de fail-closed preservada no Notion

4.2.1 Ausencia de Evidence executed NAO implica que execucao nao ocorreu
	Caso: Backend executou mas nao conseguiu gravar Evidence no Notion
	Deteccao: audit.log confirma execucao mas Notion nao tem Evidence
	Acao: Criar Evidence manualmente a partir de audit.log (nao confiar em status UI)

4.2.2 Presenca de Evidence executed implica que execucao ocorreu SE e somente SE trace_id confirmado em audit.log
	Caso: Evidence executed existe mas audit.log nao confirma
	Conclusao: Evidence e falso (criado manualmente)
	Acao: Deletar Evidence e investigar como foi criado

4.3 Separacao entre intencao e realizacao

4.3.1 Notion declara intencao (request_created, authorization_requested, execution_requested)
	Semantica: Usuario quer que algo aconteca
	Garantia: Nenhuma

4.3.2 Backend confirma realizacao (authorized, denied, executed, execution_failed, execution_blocked)
	Semantica: Algo aconteceu de fato
	Garantia: Auditado e irrefutavel (se audit.log intacto)

4.3.3 Estado transitorio entre intencao e realizacao e normal
	Exemplo: authorization_requested existe mas authorized ainda nao
	Interpretacao: Request em andamento, nao inconsistencia

4.3.4 Estado final requer confirmacao backend
	Regra: request_id so pode ser considerado concluido se tem Evidence backend de conclusao
	Evidence backend de conclusao: executed, execution_failed, execution_blocked, denied, auth_failure
	Request sem Evidence backend de conclusao: Estado PENDING ou UNKNOWN

================================================================================

FIM DO DOCUMENTO EXECUTION SEMANTICS V1

